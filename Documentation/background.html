<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>background API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>background</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import pandas as pd
import datetime
import re
from tkinter import *
from astropy.io import fits
from matplotlib import pyplot as plt
from entry_int import EntryInt
from tkinter.filedialog import askopenfilename
from interval_selector import IntervalSelector


class BackgroundWindow:
    &#34;&#34;&#34;Class to create a background Window&#34;&#34;&#34;
    # FIXME: When tests are finished, remember to set fname as None, this is just to gain time for each test
    fname = &#39;solo_L1A_stix-sci-spectrogram&#39; \
            &#39;-2102140001_20210214T014006-20210214T015515_008648_V01.fits&#39;

    def __init__(self, root, show=True):
        &#34;&#34;&#34;The main interest of this class is to calculate background caused by instruments and plot the data after
        removal of the background. As for plotting.py, this class opens a new window (if show=True) to let the user
        decide plotting options such as unit type, data type, energy bands, time intervals, and calculation method for
        background. Parameters: \n
            show (bool): if True, a new window called &#39;Select Background&#39; will be opened, containing options to plot
                         data, background, and error.&#34;&#34;&#34;

        self.root = root            # Root of the file
        self.hdul = None            # Opened file
        self.hdulist = None         # Data reading
        self.name = None            # Name of the .fits file imported

        self.counts = None          # Matrix contaning the counts per band in function of time time
        self.counts_err = None      # Matrix contaning the error of the counts per band in function of time
        self.times = None           # Index of times for x axis
        self.del_times = None       # List containing the difference between two successive times
        self.data = None            # Converts self.counts in chosen unit (rate, counts or flux) and adds time index
        self.data_err = None        # Converts self.counts_err in chosen unit (rate, counts or flux) and adds time index
        self.del_data = None        # Delayed data to match times
        self.bkg = None             # Calculated background noise
        self.data_bkg = None        # Data without background noise
        self.area = 6               # Area of the surface of detection of the telescope in cmÂ²; used for the flux

        self.nb_bands = StringVar()     # Number of energy bands to plot
        self.lower_bands = list()       # Lower bounds for energy bands from .fits file
        self.upper_bands = list()       # Upper bounds for energy bands from .fits file
        self.energies_low = []          # Lower bounds for energy bands chosen by user
        self.energies_high = []         # Upper bounds for energy bands chosen by user
        self.rounded = int()            # Nearest rounded value to fit in energy list; used in function self.round

        self.start_date = []            # Starting date at format YYYY-MM-DD-HH-MM-SS
        self.end_date = []              # Ending date at format YYYY-MM-DD-HH-MM-SS
        self.date_day = None            # Date at format YYYY-MM-DD
        self.date_time = None           # Time at format HH-MM-SS
        self.start_time = int()         # Starting time in seconds
        self.end_time = int()           # Ending time in seconds

        self.choice_bands = None                        # OptionMenu to choose number of bands
        self.list_bands = (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;)     # Choices for number of bands dropdown list

        self.type = str()                               # Data type (rate, counts, flux)
        self.unit_var = StringVar()                     # StringVar for data type
        self.unit_choices = (&#39;Rate&#39;, &#39;Counts&#39;, &#39;Flux&#39;)  # Choices for data type

        self.method_list = list()                       # Background methods calculation
        self.method_var = list()                        # StringVars for background methods calculation
        self.method_choices = (&#39;Median&#39;, &#39;Mean&#39;, &#39;1Poly&#39;, &#39;2Poly&#39;, &#39;3Poly&#39;, &#39;Exp&#39;)  # Choices for background methods

        if show:
            self.bkg_window = None          # Background main window
            self.frame1 = None              # Frame 1: Data &amp; Unit Plotting
            self.frame2 = None              # Frame 2: Number of Bands Selection
            self.frame3 = None              # Frame 3: Energy Interval Selection
            self.frame4 = None              # Frame 4: Time Interval Selection
            self.frame5 = None              # Frame 5: Plot Units

            self.state_bkg = DISABLED       # State for buttons in frame 3
            self.state_time = DISABLED      # State for buttons in frame 4
            self.backup_bkg = 0             # Keeps trace of number of boxes with bkg have been ticked in frame 1

            self.label1 = None              # Title label for frame 1
            self.label_filename = None      # Text for choosing file
            self.label2 = None              # Title label for frame 2
            self.text_min_energy = None     # Text for min energy
            self.text_max_energy = None     # Text for max energy
            self.label4 = None              # Title label for frame 3
            self.text_start_time = None     # Text for starting time
            self.text_end_time = None       # Text for ending time
            self.text_noise = None          # Text for noise calculation method
            self.label5 = None              # Title label for frame 5

            self.menu_units = None                  # Dropdown list to choose data unit type
            self.btn_time_profile_plotting = None   # Plot time profile button
            self.close = None                       # Close button

            self.text_filename = None               # Entrybox displaying the path of the chosen file
            self.btn_browse = None                  # Browse button to import a file
            self.btn_og_data = None                 # Checkbutton to plot original data
            self.btn_bkg = None                     # Checkbutton to plot background noise
            self.btn_data_bkg = None                # Checkbutton to plot data after removing background noise
            self.btn_error = None                   # Checkbutton to plot error on data
            self.btn_sep_times = None               # Checkbutton to decide different times for each band for background

            self.var_og_data = IntVar(value=1)      # Variable for original data checkbox; ticked by default
            self.var_bkg = IntVar()                 # Variable for background checkbox
            self.var_data_bkg = IntVar()            # Variable for data - background checkbox
            self.var_error = IntVar()               # Variable for error checkbox
            self.var_sep_times = IntVar(value=1)    # Variable for separate times checkbox

            self.energy_min = list()                # Entry boxes for lower bounds of energy bands
            self.energy_max = list()                # Entry boxes for upper bounds of energy bands
            self.time_min = list()                  # Entry boxes for lower bounds of time intervals
            self.time_max = list()                  # Entry boxes for upper bounds of time intervals
            self.btn_graphical = list()             # Buttons to select time intervals on the time profile plot
            self.method_selection = list()          # Dropdown lists to select method for background calculation

            self.energy_min_list = list()           # Storage for lower bounds of energy bands
            self.energy_max_list = list()           # Storage for upper bounds of energy bands
            self.time_min_list = list()             # Storage for lower bounds of time intervals
            self.time_max_list = list()             # Storage for upper bounds of time intervals

            self.bkg_start_time = list()            # Storage for starting times selected on &#34;Graphical&#34;
            self.bkg_end_time = list()              # Storage for ending times selected on &#34;Graphical&#34;
            self.bkg_start_index = list()           # Storage for starting indexes selected on &#34;Graphical&#34;
            self.bkg_end_index = list()             # Storage for ending indexes selected on &#34;Graphical&#34;

            self.title = str()                      # Label for the title of the plot
            self.xlabel = str()                     # Label for x axis
            self.ylabel = str()                     # Label for y axis
            self.time_scale = []                    # Time range used for the time plot
            self.plot_label = []                    # Labels of energy bands
            self.data_label = list()                # List of labels for each band for data plotting
            self.color = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;black&#39;, &#39;orange&#39;]  # Colors used to plot energy bands

            self.build_bkg_window()  # End of __init__, starting to build window

        # Half-smoothing
        # self.HalfSmooth = Label(self.frame2, text=&#34;Profile Half Smoothing width(#pts):&#34;)
        # self.HalfSmooth.place(relx=0.41, rely=0.05)
        # self.HalfSmoothList = (&#34;0&#34;, &#34;1&#34;, &#34;4&#34;, &#34;8&#34;, &#34;16&#34;, &#34;32&#34;, &#34;64&#34;, &#34;128&#34;, &#34;256&#34;)
        # self.SpinboxHalfSmooth = Spinbox(self.frame2, values=self.HalfSmoothList)
        # self.SpinboxHalfSmooth.place(relx=0.63, rely=0.05, width=50)

    # =================== Building window ===================

    def build_bkg_window(self):
        &#34;&#34;&#34;Builds the main components of the background window and the first frame; waits for the user to choose a file
        to build the second frame.&#34;&#34;&#34;

        # =================== Window definition ===================

        self.bkg_window = Toplevel()
        self.bkg_window.title(&#39;STIX Background Options&#39;)
        self.bkg_window.geometry(&#34;1000x600&#34;)
        Label(self.bkg_window,
              text=&#34;Select Background&#34;,
              fg=&#34;black&#34;,
              font=&#34;Helvetica 12 bold italic&#34;).pack()

        self.close = Button(self.bkg_window, text=&#34;Close&#34;, command=self.destroy)
        self.close.place(relx=0.5, rely=0.95, anchor=&#39;center&#39;)

        # =================== 1st frame : Data &amp; Unit Plotting ===================

        self.frame1 = LabelFrame(self.bkg_window, relief=RAISED, borderwidth=2)
        self.frame1.place(relx=0.025, rely=0.05, relheight=0.15, relwidth=0.95)

        self.label_filename = Label(self.frame1, text=&#34;Spectrum or Image File: &#34;)
        self.label_filename.place(relx=0.02, rely=0.25, anchor=W)
        self.text_filename = Entry(self.frame1, width=20)
        self.text_filename.place(relx=0.19, rely=0.25, relheight=0.3, relwidth=0.57, anchor=W)
        if BackgroundWindow.fname:
            self.text_filename.insert(0, BackgroundWindow.fname)
            self.open_file(BackgroundWindow.fname)
        else:
            self.text_filename.insert(0, &#34;No file chosen&#34;)

        self.btn_browse = Button(self.frame1, text=&#39;Browse -&gt;&#39;, command=self.open_file)
        self.btn_browse.place(relx=0.78, rely=0.25, anchor=W)

        self.label1 = Label(self.frame1, text=&#34;Plot time profile for: &#34;)
        self.label1.place(relx=0.02, rely=0.65, anchor=W)

        self.btn_og_data = Checkbutton(self.frame1, text=&#34;Data&#34;, variable=self.var_og_data)
        self.btn_og_data.place(relx=0.19, rely=0.65, anchor=W)

        self.btn_bkg = Checkbutton(self.frame1, text=&#34;Background&#34;, variable=self.var_bkg, command=self.disable_bkg)
        self.btn_bkg.place(relx=0.26, rely=0.65, anchor=W)

        self.btn_data_bkg = Checkbutton(self.frame1, text=&#34;Data-Background&#34;, variable=self.var_data_bkg,
                                        command=self.disable_bkg)
        self.btn_data_bkg.place(relx=0.37, rely=0.65, anchor=W)

        self.btn_error = Checkbutton(self.frame1, text=&#34;Error&#34;, variable=self.var_error)
        self.btn_error.place(relx=0.51, rely=0.65, anchor=W)

    def build_second_frame(self):
        &#34;&#34;&#34;After selecting the file, builds the second frame, containing a list with the number of energy bands;
        waits for the user to select the number of bands to build the other frames.&#34;&#34;&#34;

        # =================== 2nd frame : Number of Bands Selection ===================

        self.frame2 = Canvas(self.bkg_window, relief=RAISED, borderwidth=2)
        self.frame2.place(relx=0.025, rely=0.2, relheight=0.3, relwidth=0.15)

        self.label2 = Label(self.frame2, text=&#34;Energy bands selection: &#34;)
        self.label2.place(relx=0.5, rely=0.05, anchor=N)

        self.nb_bands = StringVar(self.frame2)
        self.nb_bands.set(&#39;-&#39;)
        self.choice_bands = OptionMenu(self.frame2, self.nb_bands, *self.list_bands)
        self.choice_bands.place(relx=0.5, rely=0.20, anchor=N)
        self.nb_bands.trace(&#34;w&#34;, self.build_other_frames)

    def build_other_frames(self, *args):
        &#34;&#34;&#34;Builds third, fourth and fifth frames. Buttons call for their respective functions.&#34;&#34;&#34;

        # =================== 3rd frame : Energy Interval Selection ===================

        self.frame3 = Frame(self.bkg_window, relief=RAISED, borderwidth=2)
        self.frame3.place(relx=0.175, rely=0.2, relheight=0.3, relwidth=0.80)

        self.text_min_energy = Label(self.frame3, text=&#34;Min energy&#34;)
        self.text_min_energy.place(relx=0.375, rely=0.18, anchor=&#34;center&#34;)
        self.text_max_energy = Label(self.frame3, text=&#34;Max energy&#34;)
        self.text_max_energy.place(relx=0.625, rely=0.18, anchor=&#34;center&#34;)

        # =================== 4th frame : Time Interval Selection ===================

        self.frame4 = Frame(self.bkg_window, relief=RAISED, borderwidth=2)
        self.frame4.place(relx=0.025, rely=0.5, relheight=0.3, relwidth=0.95)

        self.label4 = Label(self.frame4, text=&#34;Time interval selection for background noise: &#34;)
        self.label4.place(relx=0.01, rely=0.05)

        self.btn_sep_times = Checkbutton(self.frame4, text=&#34;Same time interval for all bands&#34;,
                                         variable=self.var_sep_times, command=self.disable_times,
                                         state=self.state_bkg)
        self.btn_sep_times.place(relx=0.95, rely=0.01, anchor=NE)

        self.text_start_time = Label(self.frame4, text=&#34;Start time&#34;)
        self.text_start_time.place(relx=0.2, rely=0.16, anchor=N)
        self.text_end_time = Label(self.frame4, text=&#34;End time&#34;)
        self.text_end_time.place(relx=0.4, rely=0.16, anchor=N)

        self.text_noise = Label(self.frame4, text=&#34;Method for noise calculation: &#34;)
        self.text_noise.place(relx=0.85, rely=0.16, anchor=N)

        # =================== 5th frame : Plot Units ===================

        self.frame5 = LabelFrame(self.bkg_window, relief=RAISED, borderwidth=2)
        self.frame5.place(relx=0.025, rely=0.8, relheight=0.1, relwidth=0.95)

        self.label5 = Label(self.frame5, text=&#34;Plot units: &#34;)
        self.label5.place(relx=0.01, rely=0.5, anchor=W)

        self.unit_var = StringVar(self.frame5)
        self.unit_var.set(self.unit_choices[0])
        self.type = self.unit_var.get()
        self.menu_units = OptionMenu(self.frame5, self.unit_var, *self.unit_choices)
        self.menu_units.place(relx=0.1, rely=0.5, anchor=W)

        self.btn_time_profile_plotting = Button(self.frame5, text=&#34;Plot Time Profile&#34;,
                                                command=self.time_profile_plotting)
        self.btn_time_profile_plotting.place(relx=0.3, rely=0.5, anchor=&#34;center&#34;)

        # ============== Entries for frames 3 &amp; 4 ==============

        self.entries_list()

    def destroy(self):
        &#34;&#34;&#34;Closing &#39;Select Input&#39; window when clicking &#39;Close&#39; button.&#34;&#34;&#34;
        self.bkg_window.destroy()

    def disable_bkg(self):
        &#34;&#34;&#34;If none of the checkboxes &#34;Background&#34; and &#34;Data-Background&#34; are ticked, disables all buttons in frame 4;
        else, enables them.&#34;&#34;&#34;

        # If the user (un)selects background or data-background for the plot, enales or disables all background options
        if self.var_bkg.get() + self.var_data_bkg.get() &lt; 2 and self.backup_bkg &lt; 2:
            if self.state_bkg == NORMAL:
                if self.frame4:
                    for i in range(int(self.nb_bands.get())):
                        self.time_min[i].delete(0, &#39;end&#39;)
                        self.time_max[i].delete(0, &#39;end&#39;)
                    self.btn_sep_times.select()
                self.state_bkg = DISABLED
                self.state_time = DISABLED
            else:
                self.state_bkg = NORMAL
                if self.frame4:
                    for i in range(int(self.nb_bands.get())):
                        self.time_min[i].insert(0, self.start_date)
                        self.time_max[i].insert(0, self.end_date)

        # If background frames have been built:
        if self.frame4:
            self.btn_sep_times.config(state=self.state_bkg)
            self.time_min[0].config(state=self.state_bkg)
            self.time_max[0].config(state=self.state_bkg)
            self.btn_graphical[0].config(state=self.state_bkg)
            self.method_selection[0].config(state=self.state_bkg)
            for i in range(1, int(self.nb_bands.get())):
                self.time_min[i].config(state=self.state_time)
                self.time_max[i].config(state=self.state_time)
                self.btn_graphical[i].config(state=self.state_time)
                self.method_selection[i].config(state=self.state_time)

            if self.time_min[0].get() == &#39;&#39;:
                self.time_min[0].insert(0, self.start_date)
            if self.time_max[0].get() == &#39;&#39;:
                self.time_max[0].insert(0, self.end_date)

        # Backup variable is used to compare old state of background checkboxes;
        # So if user ticks both background &amp; data-background, background frames will remain active.
        self.backup_bkg = self.var_bkg.get() + self.var_data_bkg.get()

    def disable_times(self):
        &#34;&#34;&#34;Allows user to set different time intervals for each band for background calculation. If the checkbutton
        &#34;Same time interval for all bands&#34; is ticked, disables all buttons in frame 4, except for the first band;
        else, enables all other buttons in frame 4.&#34;&#34;&#34;

        if self.state_time == NORMAL:
            self.state_time = DISABLED
            for i in range(1, int(self.nb_bands.get())):
                self.time_min[i].delete(0, &#39;end&#39;)
                self.time_max[i].delete(0, &#39;end&#39;)
        else:
            self.state_time = NORMAL
            for i in range(1, int(self.nb_bands.get())):
                self.time_min[i].insert(0, self.start_date)
                self.time_max[i].insert(0, self.end_date)

        for i in range(1, int(self.nb_bands.get())):
            self.time_min[i].config(state=self.state_time)
            self.time_max[i].config(state=self.state_time)
            self.btn_graphical[i].config(state=self.state_time)
            self.method_selection[i].config(state=self.state_time)

            if self.time_min[i].get() == &#39;&#39;:
                self.time_min[i].insert(0, self.start_date)
            if self.time_max[i].get() == &#39;&#39;:
                self.time_max[i].insert(0, self.end_date)

    # =================== Reading file ===================

    def open_file(self, file=None):
        &#34;&#34;&#34;Reads the input data using Astropy library. It can be any extension. RHESSI .fits files are analysed. \n
        Parameters: \n
            file: if a file has already been opened previously (i.e. in background), automatically re-reads it instead
            of asking user to choose it again.&#34;&#34;&#34;
        if file:
            self.name = file
        else:
            self.name = askopenfilename(initialdir=&#34;.&#34;,
                                        filetypes=((&#34;FITS files&#34;, &#34;*.fits&#34;), (&#34;All Files&#34;, &#34;*.*&#34;)),
                                        title=&#34;Please Select Spectrum or Image File&#34;)
        self.text_filename.delete(0, &#39;end&#39;)
        BackgroundWindow.fname = self.name

        if self.name:  # If file has been chosen by user
            with fits.open(self.name) as hdul:
                self.hdul = hdul

                # Loads headers informations
                time_summarize = [self.hdul[2].data.time[-1], self.hdul[0].header[19],
                                  self.hdul[0].header[21]]  # time data
                self.start_date, self.end_date = time_summarize[1], time_summarize[2]
                self.text_filename.insert(0, self.name)  # Displays the input file name in Entry box
                self.lower_bands = np.array(self.hdul[3].data.e_low)
                self.upper_bands = np.array(self.hdul[3].data.e_high)

            # Loading data
            data1, data2, header0, header1 = self.load_data(self.name)
            self.times = data1.time
            self.counts = data1.counts
            self.counts_err = data1.counts_err

            self.del_times = self.delay_times(data1.timedel)

            start_time = self.find_time(self.start_date)
            end_time = self.find_time(self.end_date)
            self.start_time = start_time[0] * 3600 + start_time[1] * 60 + start_time[2]
            self.end_time = end_time[0] * 3600 + end_time[1] * 60 + end_time[2]

            # Importing plotting.py with self.name now chosen
            self.build_second_frame()
        else:
            self.text_filename.insert(0, &#34;No file chosen&#34;)

    @staticmethod
    def load_data(file):
        &#34;&#34;&#34;Reads the Data and Header contents from input file. Loads the input file choosen in &#39;Select Input&#39; section.
        Returns respectively a table containing datas, energies, dates and channels.\n
        Parameters: \n
            file: contains the data in a fits file.&#34;&#34;&#34;
        hdulist = fits.open(file)   # Reads the data
        hdulist.info()              # Displays the content of the read file
        return hdulist[2].data, hdulist[3].data, hdulist[0].header, hdulist[3].header

    def find_time(self, date):
        &#34;&#34;&#34;Converts the starting time in the data. \n
        Parameters: \n
            date: starting date as a list.&#34;&#34;&#34;
        date_split = re.split(&#39;T&#39;, date)
        self.date_day = re.split(&#39;-&#39;, date_split[0])
        self.date_time = re.split(&#39;:&#39;, date_split[1])
        int_time_sec = re.split(&#39;\\.&#39;, self.date_time[2])
        found_time = (int(self.date_time[0]), int(self.date_time[1]), int(int_time_sec[0]))
        return found_time

    @staticmethod
    def delay_times(data):
        &#34;&#34;&#34;Creates a TEMPORARY -1 interval, because of the step between deltimes data. Returns the shifted data. \n
        Parameters: \n
            data: original data.&#34;&#34;&#34;
        del_data = np.zeros_like(data)
        for i in range(1, len(data)):
            del_data[i] = data[i - 1]
        del_data[0] = data[0]
        return del_data

    # =================== Getting user values ===================

    def entries_list(self):
        &#34;&#34;&#34;Allows to create all buttons and Entry boxes to choose energy values.&#34;&#34;&#34;
        if self.nb_bands.get().isdigit():
            self.energy_min = [&#39;&#39;] * int(self.nb_bands.get())
            self.energy_max = [&#39;&#39;] * int(self.nb_bands.get())
            self.energy_min_list = [&#39;&#39;] * int(self.nb_bands.get())
            self.energy_max_list = [&#39;&#39;] * int(self.nb_bands.get())

            self.time_min = [&#39;&#39;] * int(self.nb_bands.get())
            self.time_max = [&#39;&#39;] * int(self.nb_bands.get())
            self.time_min_list = [&#39;&#39;] * int(self.nb_bands.get())
            self.time_max_list = [&#39;&#39;] * int(self.nb_bands.get())

            self.bkg_start_time = [&#39;&#39;] * int(self.nb_bands.get())
            self.bkg_end_time = [&#39;&#39;] * int(self.nb_bands.get())
            self.bkg_start_index = [&#39;&#39;] * int(self.nb_bands.get())
            self.bkg_end_index = [&#39;&#39;] * int(self.nb_bands.get())

            self.method_selection = [&#39;&#39;] * int(self.nb_bands.get())
            self.method_list = [&#39;&#39;] * int(self.nb_bands.get())

            self.btn_graphical = [&#39;&#39;] * int(self.nb_bands.get())

            for i in range(int(self.nb_bands.get())):
                self.method_var.append(StringVar(self.frame3))
                self.method_var[i].set(self.method_choices[1])

                # Getting values for each band
                self.open_value(i)

                self.energy_min_list[i] = self.energy_min[i]
                self.energy_max_list[i] = self.energy_max[i]

                self.time_min_list[i] = self.time_min[i]
                self.time_max_list[i] = self.time_max[i]

                self.method_list[i] = self.method_var[i]

    def open_value(self, i):
        &#34;&#34;&#34;Creates entry boxes to let the user choose the limits of the plot.
        Dependencies: entry_int.py&#34;&#34;&#34;
        self.energy_min[i] = EntryInt(self.frame3, width=20)
        self.energy_max[i] = EntryInt(self.frame3, width=20)

        self.energy_min[i].place(relx=0.375, rely=0.27 + 0.14 * i, anchor=N)
        self.energy_max[i].place(relx=0.625, rely=0.27 + 0.14 * i, anchor=N)

        self.time_min[i] = Entry(self.frame4, width=20, state=self.state_time)
        self.time_max[i] = Entry(self.frame4, width=20, state=self.state_time)

        self.time_min[i].place(relx=0.2, rely=0.3 + 0.14 * i, anchor=N, width=150)
        self.time_max[i].place(relx=0.4, rely=0.3 + 0.14 * i, anchor=N, width=150)

        self.time_min[i].insert(0, self.start_date)
        self.time_max[i].insert(0, self.end_date)

        self.bkg_start_index[i] = 0
        self.bkg_end_index[i] = len(self.times)

        self.btn_graphical[i] = Button(self.frame4, text=&#34;Graphical&#34;, state=self.state_time,
                                       command=lambda: self.graphical_interval(i))
        self.btn_graphical[i].place(relx=0.6, rely=0.35 + 0.14 * i, anchor=W)

        self.method_selection[i] = OptionMenu(self.frame4, self.method_var[i], *self.method_choices)
        self.method_selection[i].place(relx=0.85, rely=0.35 + 0.14 * i, anchor=&#34;center&#34;)
        self.method_selection[i].config(state=self.state_time)

        self.time_min[0].config(state=self.state_bkg)
        self.time_max[0].config(state=self.state_bkg)
        self.btn_graphical[0].config(state=self.state_bkg)
        self.method_selection[0].config(state=self.state_bkg)

    def graphical_interval(self, i):
        &#34;&#34;&#34;Calls for interval_selection.py to plot data graph. Time interval can directly be chosen on the graph.
        Stores starting and ending times in two lists. Dependencies: interval_selection.py&#34;&#34;&#34;
        self.type = self.unit_var.get()
        self.add_bands()
        self.get_data()
        self.plot_options()

        self.bkg_start_time[i], self.bkg_end_time[i] = \
            IntervalSelector(self.times, self.data,
                             x_scale=self.time_scale,
                             plot_label=self.plot_label,
                             col_label=self.data_label,
                             title=self.title,
                             xlabel=self.xlabel,
                             ylabel=self.ylabel,
                             color=self.color,
                             samefig=self.var_sep_times.get(),
                             band=i).graphical_selection()

        if self.bkg_start_time[i] &lt; 0:
            self.bkg_start_time[i] = 0
        if self.bkg_end_time[i] &gt; self.end_time - self.start_time:
            self.bkg_end_time[i] = self.end_time - self.start_time

        self.time_min[i].delete(0, &#39;end&#39;)
        self.time_max[i].delete(0, &#39;end&#39;)

        self.time_min[i].insert(0, self.convert_time_to_date(self.bkg_start_time[i] + self.start_time))
        self.time_max[i].insert(0, self.convert_time_to_date(self.bkg_end_time[i] + self.start_time))

        self.bkg_start_index[i] = self.round_value(self.times, self.bkg_start_time[i])
        self.bkg_end_index[i] = self.round_value(self.times, self.bkg_end_time[i])

    def convert_time_to_date(self, time):
        &#34;&#34;&#34;Converts a time in seconds to a date at format YYYY-MM-DD-HH-MM-SS. \n
        Parameters: \n
            time: time to convert in sec. \n
        Returns: \n
            date: date at format YYYY-MM-DD-HH-MM-SS.&#34;&#34;&#34;
        days = int(self.date_day[2])
        hours = int(np.floor(time / 3600))
        minutes = int(np.floor((time / 3600 - hours) * 60))
        seconds = float(int((((time / 3600 - np.floor(time / 3600)) * 60) - minutes) * 60 * 1000) / 1000)

        # Delaying the day if observation if made on several days
        while hours &lt; 0 or hours &gt;= 24:
            diff_days = int(np.floor(hours / 24))
            hours -= diff_days * 24
            days += diff_days

        # Adding zeros to strings to have a better display
        if hours &lt; 10:
            hours = &#39;0&#39; + str(hours)
        if minutes &lt; 10:
            minutes = &#39;0&#39; + str(minutes)
        if seconds &lt; 10:
            seconds = &#39;0&#39; + str(seconds)
        if 100 * float(seconds) - np.floor(100 * float(seconds)) == 0:
            seconds = str(seconds) + &#39;0&#39;
            if 10 * float(seconds) - np.floor(10 * float(seconds)) == 0:
                seconds = str(seconds) + &#39;0&#39;

        return str(self.date_day[0]) + &#39;-&#39; + str(self.date_day[1]) + &#39;-&#39; + str(days) + &#39;T&#39; + str(hours) + &#39;:&#39; + \
            str(minutes) + &#39;:&#39; + str(seconds)

    def add_bands(self):
        &#34;&#34;&#34;Gets the values of plot limits from user choice.
        energy_min and energy_max are the Entry boxes for min and max energy bands defined in open_value.&#34;&#34;&#34;
        self.energies_low = []
        self.energies_high = []
        for i in range(int(self.nb_bands.get())):
            if self.energy_min[i].get() != &#39;&#39;:
                self.round_value(self.lower_bands, int(self.energy_min_list[i].get()))
                self.energies_low.append(int(self.energy_min_list[i].get()))

            if self.energy_max[i].get() != &#39;&#39;:
                self.round_value(self.upper_bands, int(self.energy_max_list[i].get()))
                self.energies_high.append(int(self.energy_max_list[i].get()))

    # =================== Plotting ===================

    def round_value(self, liste, value):
        &#34;&#34;&#34;Searches for the nearest number from the list. \n
        Parameters: \n
            liste: list where researched values are stored; \n
            value: number wanted to be rounded, to match one of the given list. \n
        Returns: \n
            index: index in the list of where the value has been found.&#34;&#34;&#34;
        index = 0
        near = np.abs(value - liste[0])
        self.rounded = int(value)
        for i in range(len(liste)):
            diff = np.abs(value - liste[i])
            if near &gt; diff:
                near = diff
                index = i
                self.rounded = int(liste[i])
        return index

    def get_data(self):
        &#34;&#34;&#34;Defines the Rate, Counts, and Flux for &#34;Plot Time Profile&#34;.&#34;&#34;&#34;
        self.data = np.zeros((len(self.times), len(self.energies_low) + 1))
        self.data_err = np.zeros(np.shape(self.data))

        # Determines the energy distribution for different channels relative to the time of observed data
        for i in range(len(self.times)):
            for j in range(len(self.energies_low) + 1):
                # Last column is self.times
                if j == len(self.energies_low):
                    self.data[i, j] = self.times[i]
                    self.data_err[i, j] = self.times[i]

                # Each column is the data for a band
                else:
                    if np.where(self.lower_bands == self.energies_low[j])[0]:
                        a = (np.where(self.lower_bands == self.energies_low[j]))[0][0]
                    else:
                        self.round_value(self.lower_bands, self.energies_low[j])
                        a = (np.where(self.lower_bands == self.rounded))[0][0]

                    if np.where(self.upper_bands == self.energies_high[j])[0]:
                        b = (np.where(self.upper_bands == self.energies_high[j]))[0][0]
                    else:
                        self.round_value(self.upper_bands, self.energies_high[j])
                        b = (np.where(self.upper_bands == self.rounded))[0][0]

                    # Transformaing data and error data according to unit type
                    if self.type == &#39;Rate&#39;:
                        self.data[i, j] = sum(self.counts[i, a:(b + 1)]) / self.del_times[i]
                        self.data_err[i, j] = sum(self.counts_err[i, a:(b + 1)]) / self.del_times[i]
                    elif self.type == &#39;Counts&#39;:
                        self.data[i, j] = sum(self.counts[i, a:(b + 1)])
                        self.data_err[i, j] = sum(self.counts_err[i, a:(b + 1)])
                    elif self.type == &#39;Flux&#39;:
                        e_diff = self.area * np.abs(self.energies_high[j] - self.energies_low[j])
                        self.data[i, j] = sum(self.counts[i, a:(b + 1)]) / self.del_times[i] / e_diff
                        self.data_err[i, j] = sum(self.counts_err[i, a:(b + 1)]) / self.del_times[i] / e_diff
                    else:
                        print(&#34;No matching unit plotting type found&#34;)

    def get_bkg(self):
        &#34;&#34;&#34;Plots the function of time by selected Unit. Uses the colormesh function provided by matplotlib library.&#34;&#34;&#34;
        self.bkg = np.zeros(np.shape(self.data))
        for band in range(len(self.energies_low) + 1):
            if band == len(self.energies_low):
                self.bkg[:, band] = self.times
            else:
                if self.var_sep_times.get() == 1:
                    if band != 0:
                        self.method_var[band].set(self.method_var[0].get())
                        self.method_list[band] = self.method_var[band]
                        self.bkg_start_index[band] = self.bkg_start_index[0]
                        self.bkg_end_index[band] = self.bkg_end_index[0]

                start = self.bkg_start_index[band]
                end = self.bkg_end_index[band]

                # Insert conditions on the method of calculation
                if self.method_list[band].get() == &#34;Median&#34;:
                    self.bkg[:, band] = np.median(self.data[start:end, band])

                elif self.method_list[band].get() == &#34;Mean&#34;:
                    self.bkg[:, band] = np.mean(self.data[start:end, band])

                elif self.method_list[band].get() == &#34;1Poly&#34;:
                    poly = np.poly1d(np.polyfit(self.times[start:end], self.data[start:end, band], 1))
                    for time in range(len(self.times)):
                        self.bkg[time, band] = poly(time)

                elif self.method_list[band].get() == &#34;2Poly&#34;:
                    poly = np.poly1d(np.polyfit(self.times[start:end], self.data[start:end, band], 2))
                    for time in range(len(self.times)):
                        self.bkg[time, band] = poly(time)

                elif self.method_list[band].get() == &#34;3Poly&#34;:
                    poly = np.poly1d(np.polyfit(self.times[start:end], self.data[start:end, band], 3))
                    for time in range(len(self.times)):
                        self.bkg[time, band] = poly(time)

                elif self.method_list[band].get() == &#34;Exp&#34;:
                    poly = np.polyfit(self.times[start:end], np.log(self.data[start:end, band]), 1)
                    for time in range(len(self.times)):
                        a = np.exp(poly[1])
                        b = poly[0]
                        self.bkg[time, band] = a * np.exp(b * self.times[time])

                else:
                    self.bkg[:, band] = 0
                    print(&#34;Background detection method not found&#34;)

                # Removing all negative values in the background
                for time in range(len(self.times)):
                    if self.bkg[time, band] &lt; 0:
                        self.bkg[time, band] = 0

    def get_data_bkg(self):
        &#34;&#34;&#34;Plots the function of time by selected Unit. Uses the colormesh function provided by matplotlib library.&#34;&#34;&#34;
        self.data_bkg = np.zeros(np.shape(self.data))
        for band in range(len(self.energies_low) + 1):
            if band == len(self.energies_low):
                self.data_bkg[:, band] = self.times
            else:
                for time in range(len(self.times)):
                    self.data_bkg[time, band] = self.data[time, band] - self.bkg[time, band]
                    if self.data_bkg[time, band] &lt; 0:
                        self.data_bkg[time, band] = 0

    def plot_options(self):
        &#34;&#34;&#34;Saves using matplotlib all options to plot the graph to later display it. \n
        Dependencies: time_profile_plotting&#34;&#34;&#34;
        # Absciss legend plot
        file_duration = max(self.times) - min(self.times)
        if file_duration &lt;= 1800:  # file duration less than 30 minutes
            step_x = 120
        elif file_duration &lt;= 3600:  # file duration less than 1 hour
            step_x = 480
        elif file_duration &lt;= 28800:  # file duration less than 8 hours
            step_x = 3600
        else:  # file duration more than 8 hours
            step_x = 7200

        self.time_scale = np.arange(0, file_duration, step_x)
        x_labels_plot = list(
            map(lambda x: (str(datetime.timedelta(seconds=x))).split(&#39;.&#39;)[0][:-3], self.time_scale +
                self.start_time))

        self.plot_label = []
        for i in range(len(x_labels_plot)):
            if &#39;day&#39; in x_labels_plot[i]:
                self.plot_label.append((x_labels_plot[i].split(&#39;,&#39;))[1])
            else:
                self.plot_label.append(x_labels_plot[i])

        self.xlabel = &#39;Start time: &#39; + str(self.start_date) + &#39; -- End time : &#39; + str(self.end_date)

        # Unit plotting
        if self.type == &#34;Rate&#34;:
            self.ylabel = &#39;Rate (Counts/s) by Bands&#39;
            self.title = &#39;Time Profile Plotting Rate (Counts/s)&#39;

        elif self.type == &#34;Counts&#34;:
            self.ylabel = &#39;Counts by Bands&#39;
            self.title = &#39;Time Profile Plotting Counts&#39;

        elif self.type == &#34;Flux&#34;:
            self.ylabel = &#39;Flux by Bands&#39;
            self.title = &#39;Time Profile Plotting Flux&#39;

        else:
            print(&#34;No matching unit plotting type found&#34;)

        # Labeling energy bands on the plot
        self.data_label = []
        for data_type in [&#39;Original data&#39;, &#39;Background&#39;, &#39;Corrected data&#39;]:
            label = [data_type + &#39; for &#39; + str(low) + &#39;-&#39; + str(high) + &#39;keV&#39; for low, high in
                     zip(self.energies_low, self.energies_high)]
            label.append(&#39;Times&#39;)
            self.data_label.append(label)

    def time_profile_plotting(self):
        &#34;&#34;&#34;Calls for all previous functions to get all data needed, then show the plot.
        Dependencies: get_data, get_bkg, get_data_bkg, plot_options&#34;&#34;&#34;
        plt.close()
        self.add_bands()
        self.type = self.unit_var.get()
        self.get_data()
        plt.figure()
        self.plot_options()

        # Plotting data
        if self.var_error.get():
            yerr = self.data_err
        else:
            yerr = np.zeros(np.shape(self.data_err))

        if self.var_og_data.get():
            df = pd.DataFrame(self.data, index=self.times, columns=self.data_label[0])
            for band in range(len(self.energies_low)):
                df.plot(x=&#39;Times&#39;, y=self.data_label[0][band], yerr=yerr[:, band], color=self.color[band],
                        ax=plt.gca(), linewidth=0.25)

        if self.var_bkg.get() or self.var_data_bkg.get():
            self.get_bkg()

            if self.var_bkg.get():
                df = pd.DataFrame(self.bkg, index=self.times, columns=self.data_label[1])
                for band in range(len(self.energies_low)):
                    df.plot(x=&#39;Times&#39;, y=self.data_label[1][band], color=self.color[band],
                            ax=plt.gca(), linewidth=0.1)

            if self.var_data_bkg.get():
                self.get_data_bkg()
                df = pd.DataFrame(self.data_bkg, index=self.times, columns=self.data_label[2])
                for band in range(len(self.energies_low)):
                    df.plot(x=&#39;Times&#39;, y=self.data_label[2][band], yerr=yerr[:, band], color=self.color[band],
                            ax=plt.gca(), linewidth=1)

        plt.xticks(self.time_scale, self.plot_label)
        plt.xlabel(self.xlabel)
        plt.ylabel(self.ylabel)
        plt.title(self.title)
        plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="background.BackgroundWindow"><code class="flex name class">
<span>class <span class="ident">BackgroundWindow</span></span>
<span>(</span><span>root, show=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to create a background Window</p>
<p>The main interest of this class is to calculate background caused by instruments and plot the data after
removal of the background. As for plotting.py, this class opens a new window (if show=True) to let the user
decide plotting options such as unit type, data type, energy bands, time intervals, and calculation method for
background. Parameters: </p>
<pre><code>show (bool): if True, a new window called 'Select Background' will be opened, containing options to plot
             data, background, and error.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BackgroundWindow:
    &#34;&#34;&#34;Class to create a background Window&#34;&#34;&#34;
    # FIXME: When tests are finished, remember to set fname as None, this is just to gain time for each test
    fname = &#39;solo_L1A_stix-sci-spectrogram&#39; \
            &#39;-2102140001_20210214T014006-20210214T015515_008648_V01.fits&#39;

    def __init__(self, root, show=True):
        &#34;&#34;&#34;The main interest of this class is to calculate background caused by instruments and plot the data after
        removal of the background. As for plotting.py, this class opens a new window (if show=True) to let the user
        decide plotting options such as unit type, data type, energy bands, time intervals, and calculation method for
        background. Parameters: \n
            show (bool): if True, a new window called &#39;Select Background&#39; will be opened, containing options to plot
                         data, background, and error.&#34;&#34;&#34;

        self.root = root            # Root of the file
        self.hdul = None            # Opened file
        self.hdulist = None         # Data reading
        self.name = None            # Name of the .fits file imported

        self.counts = None          # Matrix contaning the counts per band in function of time time
        self.counts_err = None      # Matrix contaning the error of the counts per band in function of time
        self.times = None           # Index of times for x axis
        self.del_times = None       # List containing the difference between two successive times
        self.data = None            # Converts self.counts in chosen unit (rate, counts or flux) and adds time index
        self.data_err = None        # Converts self.counts_err in chosen unit (rate, counts or flux) and adds time index
        self.del_data = None        # Delayed data to match times
        self.bkg = None             # Calculated background noise
        self.data_bkg = None        # Data without background noise
        self.area = 6               # Area of the surface of detection of the telescope in cmÂ²; used for the flux

        self.nb_bands = StringVar()     # Number of energy bands to plot
        self.lower_bands = list()       # Lower bounds for energy bands from .fits file
        self.upper_bands = list()       # Upper bounds for energy bands from .fits file
        self.energies_low = []          # Lower bounds for energy bands chosen by user
        self.energies_high = []         # Upper bounds for energy bands chosen by user
        self.rounded = int()            # Nearest rounded value to fit in energy list; used in function self.round

        self.start_date = []            # Starting date at format YYYY-MM-DD-HH-MM-SS
        self.end_date = []              # Ending date at format YYYY-MM-DD-HH-MM-SS
        self.date_day = None            # Date at format YYYY-MM-DD
        self.date_time = None           # Time at format HH-MM-SS
        self.start_time = int()         # Starting time in seconds
        self.end_time = int()           # Ending time in seconds

        self.choice_bands = None                        # OptionMenu to choose number of bands
        self.list_bands = (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;)     # Choices for number of bands dropdown list

        self.type = str()                               # Data type (rate, counts, flux)
        self.unit_var = StringVar()                     # StringVar for data type
        self.unit_choices = (&#39;Rate&#39;, &#39;Counts&#39;, &#39;Flux&#39;)  # Choices for data type

        self.method_list = list()                       # Background methods calculation
        self.method_var = list()                        # StringVars for background methods calculation
        self.method_choices = (&#39;Median&#39;, &#39;Mean&#39;, &#39;1Poly&#39;, &#39;2Poly&#39;, &#39;3Poly&#39;, &#39;Exp&#39;)  # Choices for background methods

        if show:
            self.bkg_window = None          # Background main window
            self.frame1 = None              # Frame 1: Data &amp; Unit Plotting
            self.frame2 = None              # Frame 2: Number of Bands Selection
            self.frame3 = None              # Frame 3: Energy Interval Selection
            self.frame4 = None              # Frame 4: Time Interval Selection
            self.frame5 = None              # Frame 5: Plot Units

            self.state_bkg = DISABLED       # State for buttons in frame 3
            self.state_time = DISABLED      # State for buttons in frame 4
            self.backup_bkg = 0             # Keeps trace of number of boxes with bkg have been ticked in frame 1

            self.label1 = None              # Title label for frame 1
            self.label_filename = None      # Text for choosing file
            self.label2 = None              # Title label for frame 2
            self.text_min_energy = None     # Text for min energy
            self.text_max_energy = None     # Text for max energy
            self.label4 = None              # Title label for frame 3
            self.text_start_time = None     # Text for starting time
            self.text_end_time = None       # Text for ending time
            self.text_noise = None          # Text for noise calculation method
            self.label5 = None              # Title label for frame 5

            self.menu_units = None                  # Dropdown list to choose data unit type
            self.btn_time_profile_plotting = None   # Plot time profile button
            self.close = None                       # Close button

            self.text_filename = None               # Entrybox displaying the path of the chosen file
            self.btn_browse = None                  # Browse button to import a file
            self.btn_og_data = None                 # Checkbutton to plot original data
            self.btn_bkg = None                     # Checkbutton to plot background noise
            self.btn_data_bkg = None                # Checkbutton to plot data after removing background noise
            self.btn_error = None                   # Checkbutton to plot error on data
            self.btn_sep_times = None               # Checkbutton to decide different times for each band for background

            self.var_og_data = IntVar(value=1)      # Variable for original data checkbox; ticked by default
            self.var_bkg = IntVar()                 # Variable for background checkbox
            self.var_data_bkg = IntVar()            # Variable for data - background checkbox
            self.var_error = IntVar()               # Variable for error checkbox
            self.var_sep_times = IntVar(value=1)    # Variable for separate times checkbox

            self.energy_min = list()                # Entry boxes for lower bounds of energy bands
            self.energy_max = list()                # Entry boxes for upper bounds of energy bands
            self.time_min = list()                  # Entry boxes for lower bounds of time intervals
            self.time_max = list()                  # Entry boxes for upper bounds of time intervals
            self.btn_graphical = list()             # Buttons to select time intervals on the time profile plot
            self.method_selection = list()          # Dropdown lists to select method for background calculation

            self.energy_min_list = list()           # Storage for lower bounds of energy bands
            self.energy_max_list = list()           # Storage for upper bounds of energy bands
            self.time_min_list = list()             # Storage for lower bounds of time intervals
            self.time_max_list = list()             # Storage for upper bounds of time intervals

            self.bkg_start_time = list()            # Storage for starting times selected on &#34;Graphical&#34;
            self.bkg_end_time = list()              # Storage for ending times selected on &#34;Graphical&#34;
            self.bkg_start_index = list()           # Storage for starting indexes selected on &#34;Graphical&#34;
            self.bkg_end_index = list()             # Storage for ending indexes selected on &#34;Graphical&#34;

            self.title = str()                      # Label for the title of the plot
            self.xlabel = str()                     # Label for x axis
            self.ylabel = str()                     # Label for y axis
            self.time_scale = []                    # Time range used for the time plot
            self.plot_label = []                    # Labels of energy bands
            self.data_label = list()                # List of labels for each band for data plotting
            self.color = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;black&#39;, &#39;orange&#39;]  # Colors used to plot energy bands

            self.build_bkg_window()  # End of __init__, starting to build window

        # Half-smoothing
        # self.HalfSmooth = Label(self.frame2, text=&#34;Profile Half Smoothing width(#pts):&#34;)
        # self.HalfSmooth.place(relx=0.41, rely=0.05)
        # self.HalfSmoothList = (&#34;0&#34;, &#34;1&#34;, &#34;4&#34;, &#34;8&#34;, &#34;16&#34;, &#34;32&#34;, &#34;64&#34;, &#34;128&#34;, &#34;256&#34;)
        # self.SpinboxHalfSmooth = Spinbox(self.frame2, values=self.HalfSmoothList)
        # self.SpinboxHalfSmooth.place(relx=0.63, rely=0.05, width=50)

    # =================== Building window ===================

    def build_bkg_window(self):
        &#34;&#34;&#34;Builds the main components of the background window and the first frame; waits for the user to choose a file
        to build the second frame.&#34;&#34;&#34;

        # =================== Window definition ===================

        self.bkg_window = Toplevel()
        self.bkg_window.title(&#39;STIX Background Options&#39;)
        self.bkg_window.geometry(&#34;1000x600&#34;)
        Label(self.bkg_window,
              text=&#34;Select Background&#34;,
              fg=&#34;black&#34;,
              font=&#34;Helvetica 12 bold italic&#34;).pack()

        self.close = Button(self.bkg_window, text=&#34;Close&#34;, command=self.destroy)
        self.close.place(relx=0.5, rely=0.95, anchor=&#39;center&#39;)

        # =================== 1st frame : Data &amp; Unit Plotting ===================

        self.frame1 = LabelFrame(self.bkg_window, relief=RAISED, borderwidth=2)
        self.frame1.place(relx=0.025, rely=0.05, relheight=0.15, relwidth=0.95)

        self.label_filename = Label(self.frame1, text=&#34;Spectrum or Image File: &#34;)
        self.label_filename.place(relx=0.02, rely=0.25, anchor=W)
        self.text_filename = Entry(self.frame1, width=20)
        self.text_filename.place(relx=0.19, rely=0.25, relheight=0.3, relwidth=0.57, anchor=W)
        if BackgroundWindow.fname:
            self.text_filename.insert(0, BackgroundWindow.fname)
            self.open_file(BackgroundWindow.fname)
        else:
            self.text_filename.insert(0, &#34;No file chosen&#34;)

        self.btn_browse = Button(self.frame1, text=&#39;Browse -&gt;&#39;, command=self.open_file)
        self.btn_browse.place(relx=0.78, rely=0.25, anchor=W)

        self.label1 = Label(self.frame1, text=&#34;Plot time profile for: &#34;)
        self.label1.place(relx=0.02, rely=0.65, anchor=W)

        self.btn_og_data = Checkbutton(self.frame1, text=&#34;Data&#34;, variable=self.var_og_data)
        self.btn_og_data.place(relx=0.19, rely=0.65, anchor=W)

        self.btn_bkg = Checkbutton(self.frame1, text=&#34;Background&#34;, variable=self.var_bkg, command=self.disable_bkg)
        self.btn_bkg.place(relx=0.26, rely=0.65, anchor=W)

        self.btn_data_bkg = Checkbutton(self.frame1, text=&#34;Data-Background&#34;, variable=self.var_data_bkg,
                                        command=self.disable_bkg)
        self.btn_data_bkg.place(relx=0.37, rely=0.65, anchor=W)

        self.btn_error = Checkbutton(self.frame1, text=&#34;Error&#34;, variable=self.var_error)
        self.btn_error.place(relx=0.51, rely=0.65, anchor=W)

    def build_second_frame(self):
        &#34;&#34;&#34;After selecting the file, builds the second frame, containing a list with the number of energy bands;
        waits for the user to select the number of bands to build the other frames.&#34;&#34;&#34;

        # =================== 2nd frame : Number of Bands Selection ===================

        self.frame2 = Canvas(self.bkg_window, relief=RAISED, borderwidth=2)
        self.frame2.place(relx=0.025, rely=0.2, relheight=0.3, relwidth=0.15)

        self.label2 = Label(self.frame2, text=&#34;Energy bands selection: &#34;)
        self.label2.place(relx=0.5, rely=0.05, anchor=N)

        self.nb_bands = StringVar(self.frame2)
        self.nb_bands.set(&#39;-&#39;)
        self.choice_bands = OptionMenu(self.frame2, self.nb_bands, *self.list_bands)
        self.choice_bands.place(relx=0.5, rely=0.20, anchor=N)
        self.nb_bands.trace(&#34;w&#34;, self.build_other_frames)

    def build_other_frames(self, *args):
        &#34;&#34;&#34;Builds third, fourth and fifth frames. Buttons call for their respective functions.&#34;&#34;&#34;

        # =================== 3rd frame : Energy Interval Selection ===================

        self.frame3 = Frame(self.bkg_window, relief=RAISED, borderwidth=2)
        self.frame3.place(relx=0.175, rely=0.2, relheight=0.3, relwidth=0.80)

        self.text_min_energy = Label(self.frame3, text=&#34;Min energy&#34;)
        self.text_min_energy.place(relx=0.375, rely=0.18, anchor=&#34;center&#34;)
        self.text_max_energy = Label(self.frame3, text=&#34;Max energy&#34;)
        self.text_max_energy.place(relx=0.625, rely=0.18, anchor=&#34;center&#34;)

        # =================== 4th frame : Time Interval Selection ===================

        self.frame4 = Frame(self.bkg_window, relief=RAISED, borderwidth=2)
        self.frame4.place(relx=0.025, rely=0.5, relheight=0.3, relwidth=0.95)

        self.label4 = Label(self.frame4, text=&#34;Time interval selection for background noise: &#34;)
        self.label4.place(relx=0.01, rely=0.05)

        self.btn_sep_times = Checkbutton(self.frame4, text=&#34;Same time interval for all bands&#34;,
                                         variable=self.var_sep_times, command=self.disable_times,
                                         state=self.state_bkg)
        self.btn_sep_times.place(relx=0.95, rely=0.01, anchor=NE)

        self.text_start_time = Label(self.frame4, text=&#34;Start time&#34;)
        self.text_start_time.place(relx=0.2, rely=0.16, anchor=N)
        self.text_end_time = Label(self.frame4, text=&#34;End time&#34;)
        self.text_end_time.place(relx=0.4, rely=0.16, anchor=N)

        self.text_noise = Label(self.frame4, text=&#34;Method for noise calculation: &#34;)
        self.text_noise.place(relx=0.85, rely=0.16, anchor=N)

        # =================== 5th frame : Plot Units ===================

        self.frame5 = LabelFrame(self.bkg_window, relief=RAISED, borderwidth=2)
        self.frame5.place(relx=0.025, rely=0.8, relheight=0.1, relwidth=0.95)

        self.label5 = Label(self.frame5, text=&#34;Plot units: &#34;)
        self.label5.place(relx=0.01, rely=0.5, anchor=W)

        self.unit_var = StringVar(self.frame5)
        self.unit_var.set(self.unit_choices[0])
        self.type = self.unit_var.get()
        self.menu_units = OptionMenu(self.frame5, self.unit_var, *self.unit_choices)
        self.menu_units.place(relx=0.1, rely=0.5, anchor=W)

        self.btn_time_profile_plotting = Button(self.frame5, text=&#34;Plot Time Profile&#34;,
                                                command=self.time_profile_plotting)
        self.btn_time_profile_plotting.place(relx=0.3, rely=0.5, anchor=&#34;center&#34;)

        # ============== Entries for frames 3 &amp; 4 ==============

        self.entries_list()

    def destroy(self):
        &#34;&#34;&#34;Closing &#39;Select Input&#39; window when clicking &#39;Close&#39; button.&#34;&#34;&#34;
        self.bkg_window.destroy()

    def disable_bkg(self):
        &#34;&#34;&#34;If none of the checkboxes &#34;Background&#34; and &#34;Data-Background&#34; are ticked, disables all buttons in frame 4;
        else, enables them.&#34;&#34;&#34;

        # If the user (un)selects background or data-background for the plot, enales or disables all background options
        if self.var_bkg.get() + self.var_data_bkg.get() &lt; 2 and self.backup_bkg &lt; 2:
            if self.state_bkg == NORMAL:
                if self.frame4:
                    for i in range(int(self.nb_bands.get())):
                        self.time_min[i].delete(0, &#39;end&#39;)
                        self.time_max[i].delete(0, &#39;end&#39;)
                    self.btn_sep_times.select()
                self.state_bkg = DISABLED
                self.state_time = DISABLED
            else:
                self.state_bkg = NORMAL
                if self.frame4:
                    for i in range(int(self.nb_bands.get())):
                        self.time_min[i].insert(0, self.start_date)
                        self.time_max[i].insert(0, self.end_date)

        # If background frames have been built:
        if self.frame4:
            self.btn_sep_times.config(state=self.state_bkg)
            self.time_min[0].config(state=self.state_bkg)
            self.time_max[0].config(state=self.state_bkg)
            self.btn_graphical[0].config(state=self.state_bkg)
            self.method_selection[0].config(state=self.state_bkg)
            for i in range(1, int(self.nb_bands.get())):
                self.time_min[i].config(state=self.state_time)
                self.time_max[i].config(state=self.state_time)
                self.btn_graphical[i].config(state=self.state_time)
                self.method_selection[i].config(state=self.state_time)

            if self.time_min[0].get() == &#39;&#39;:
                self.time_min[0].insert(0, self.start_date)
            if self.time_max[0].get() == &#39;&#39;:
                self.time_max[0].insert(0, self.end_date)

        # Backup variable is used to compare old state of background checkboxes;
        # So if user ticks both background &amp; data-background, background frames will remain active.
        self.backup_bkg = self.var_bkg.get() + self.var_data_bkg.get()

    def disable_times(self):
        &#34;&#34;&#34;Allows user to set different time intervals for each band for background calculation. If the checkbutton
        &#34;Same time interval for all bands&#34; is ticked, disables all buttons in frame 4, except for the first band;
        else, enables all other buttons in frame 4.&#34;&#34;&#34;

        if self.state_time == NORMAL:
            self.state_time = DISABLED
            for i in range(1, int(self.nb_bands.get())):
                self.time_min[i].delete(0, &#39;end&#39;)
                self.time_max[i].delete(0, &#39;end&#39;)
        else:
            self.state_time = NORMAL
            for i in range(1, int(self.nb_bands.get())):
                self.time_min[i].insert(0, self.start_date)
                self.time_max[i].insert(0, self.end_date)

        for i in range(1, int(self.nb_bands.get())):
            self.time_min[i].config(state=self.state_time)
            self.time_max[i].config(state=self.state_time)
            self.btn_graphical[i].config(state=self.state_time)
            self.method_selection[i].config(state=self.state_time)

            if self.time_min[i].get() == &#39;&#39;:
                self.time_min[i].insert(0, self.start_date)
            if self.time_max[i].get() == &#39;&#39;:
                self.time_max[i].insert(0, self.end_date)

    # =================== Reading file ===================

    def open_file(self, file=None):
        &#34;&#34;&#34;Reads the input data using Astropy library. It can be any extension. RHESSI .fits files are analysed. \n
        Parameters: \n
            file: if a file has already been opened previously (i.e. in background), automatically re-reads it instead
            of asking user to choose it again.&#34;&#34;&#34;
        if file:
            self.name = file
        else:
            self.name = askopenfilename(initialdir=&#34;.&#34;,
                                        filetypes=((&#34;FITS files&#34;, &#34;*.fits&#34;), (&#34;All Files&#34;, &#34;*.*&#34;)),
                                        title=&#34;Please Select Spectrum or Image File&#34;)
        self.text_filename.delete(0, &#39;end&#39;)
        BackgroundWindow.fname = self.name

        if self.name:  # If file has been chosen by user
            with fits.open(self.name) as hdul:
                self.hdul = hdul

                # Loads headers informations
                time_summarize = [self.hdul[2].data.time[-1], self.hdul[0].header[19],
                                  self.hdul[0].header[21]]  # time data
                self.start_date, self.end_date = time_summarize[1], time_summarize[2]
                self.text_filename.insert(0, self.name)  # Displays the input file name in Entry box
                self.lower_bands = np.array(self.hdul[3].data.e_low)
                self.upper_bands = np.array(self.hdul[3].data.e_high)

            # Loading data
            data1, data2, header0, header1 = self.load_data(self.name)
            self.times = data1.time
            self.counts = data1.counts
            self.counts_err = data1.counts_err

            self.del_times = self.delay_times(data1.timedel)

            start_time = self.find_time(self.start_date)
            end_time = self.find_time(self.end_date)
            self.start_time = start_time[0] * 3600 + start_time[1] * 60 + start_time[2]
            self.end_time = end_time[0] * 3600 + end_time[1] * 60 + end_time[2]

            # Importing plotting.py with self.name now chosen
            self.build_second_frame()
        else:
            self.text_filename.insert(0, &#34;No file chosen&#34;)

    @staticmethod
    def load_data(file):
        &#34;&#34;&#34;Reads the Data and Header contents from input file. Loads the input file choosen in &#39;Select Input&#39; section.
        Returns respectively a table containing datas, energies, dates and channels.\n
        Parameters: \n
            file: contains the data in a fits file.&#34;&#34;&#34;
        hdulist = fits.open(file)   # Reads the data
        hdulist.info()              # Displays the content of the read file
        return hdulist[2].data, hdulist[3].data, hdulist[0].header, hdulist[3].header

    def find_time(self, date):
        &#34;&#34;&#34;Converts the starting time in the data. \n
        Parameters: \n
            date: starting date as a list.&#34;&#34;&#34;
        date_split = re.split(&#39;T&#39;, date)
        self.date_day = re.split(&#39;-&#39;, date_split[0])
        self.date_time = re.split(&#39;:&#39;, date_split[1])
        int_time_sec = re.split(&#39;\\.&#39;, self.date_time[2])
        found_time = (int(self.date_time[0]), int(self.date_time[1]), int(int_time_sec[0]))
        return found_time

    @staticmethod
    def delay_times(data):
        &#34;&#34;&#34;Creates a TEMPORARY -1 interval, because of the step between deltimes data. Returns the shifted data. \n
        Parameters: \n
            data: original data.&#34;&#34;&#34;
        del_data = np.zeros_like(data)
        for i in range(1, len(data)):
            del_data[i] = data[i - 1]
        del_data[0] = data[0]
        return del_data

    # =================== Getting user values ===================

    def entries_list(self):
        &#34;&#34;&#34;Allows to create all buttons and Entry boxes to choose energy values.&#34;&#34;&#34;
        if self.nb_bands.get().isdigit():
            self.energy_min = [&#39;&#39;] * int(self.nb_bands.get())
            self.energy_max = [&#39;&#39;] * int(self.nb_bands.get())
            self.energy_min_list = [&#39;&#39;] * int(self.nb_bands.get())
            self.energy_max_list = [&#39;&#39;] * int(self.nb_bands.get())

            self.time_min = [&#39;&#39;] * int(self.nb_bands.get())
            self.time_max = [&#39;&#39;] * int(self.nb_bands.get())
            self.time_min_list = [&#39;&#39;] * int(self.nb_bands.get())
            self.time_max_list = [&#39;&#39;] * int(self.nb_bands.get())

            self.bkg_start_time = [&#39;&#39;] * int(self.nb_bands.get())
            self.bkg_end_time = [&#39;&#39;] * int(self.nb_bands.get())
            self.bkg_start_index = [&#39;&#39;] * int(self.nb_bands.get())
            self.bkg_end_index = [&#39;&#39;] * int(self.nb_bands.get())

            self.method_selection = [&#39;&#39;] * int(self.nb_bands.get())
            self.method_list = [&#39;&#39;] * int(self.nb_bands.get())

            self.btn_graphical = [&#39;&#39;] * int(self.nb_bands.get())

            for i in range(int(self.nb_bands.get())):
                self.method_var.append(StringVar(self.frame3))
                self.method_var[i].set(self.method_choices[1])

                # Getting values for each band
                self.open_value(i)

                self.energy_min_list[i] = self.energy_min[i]
                self.energy_max_list[i] = self.energy_max[i]

                self.time_min_list[i] = self.time_min[i]
                self.time_max_list[i] = self.time_max[i]

                self.method_list[i] = self.method_var[i]

    def open_value(self, i):
        &#34;&#34;&#34;Creates entry boxes to let the user choose the limits of the plot.
        Dependencies: entry_int.py&#34;&#34;&#34;
        self.energy_min[i] = EntryInt(self.frame3, width=20)
        self.energy_max[i] = EntryInt(self.frame3, width=20)

        self.energy_min[i].place(relx=0.375, rely=0.27 + 0.14 * i, anchor=N)
        self.energy_max[i].place(relx=0.625, rely=0.27 + 0.14 * i, anchor=N)

        self.time_min[i] = Entry(self.frame4, width=20, state=self.state_time)
        self.time_max[i] = Entry(self.frame4, width=20, state=self.state_time)

        self.time_min[i].place(relx=0.2, rely=0.3 + 0.14 * i, anchor=N, width=150)
        self.time_max[i].place(relx=0.4, rely=0.3 + 0.14 * i, anchor=N, width=150)

        self.time_min[i].insert(0, self.start_date)
        self.time_max[i].insert(0, self.end_date)

        self.bkg_start_index[i] = 0
        self.bkg_end_index[i] = len(self.times)

        self.btn_graphical[i] = Button(self.frame4, text=&#34;Graphical&#34;, state=self.state_time,
                                       command=lambda: self.graphical_interval(i))
        self.btn_graphical[i].place(relx=0.6, rely=0.35 + 0.14 * i, anchor=W)

        self.method_selection[i] = OptionMenu(self.frame4, self.method_var[i], *self.method_choices)
        self.method_selection[i].place(relx=0.85, rely=0.35 + 0.14 * i, anchor=&#34;center&#34;)
        self.method_selection[i].config(state=self.state_time)

        self.time_min[0].config(state=self.state_bkg)
        self.time_max[0].config(state=self.state_bkg)
        self.btn_graphical[0].config(state=self.state_bkg)
        self.method_selection[0].config(state=self.state_bkg)

    def graphical_interval(self, i):
        &#34;&#34;&#34;Calls for interval_selection.py to plot data graph. Time interval can directly be chosen on the graph.
        Stores starting and ending times in two lists. Dependencies: interval_selection.py&#34;&#34;&#34;
        self.type = self.unit_var.get()
        self.add_bands()
        self.get_data()
        self.plot_options()

        self.bkg_start_time[i], self.bkg_end_time[i] = \
            IntervalSelector(self.times, self.data,
                             x_scale=self.time_scale,
                             plot_label=self.plot_label,
                             col_label=self.data_label,
                             title=self.title,
                             xlabel=self.xlabel,
                             ylabel=self.ylabel,
                             color=self.color,
                             samefig=self.var_sep_times.get(),
                             band=i).graphical_selection()

        if self.bkg_start_time[i] &lt; 0:
            self.bkg_start_time[i] = 0
        if self.bkg_end_time[i] &gt; self.end_time - self.start_time:
            self.bkg_end_time[i] = self.end_time - self.start_time

        self.time_min[i].delete(0, &#39;end&#39;)
        self.time_max[i].delete(0, &#39;end&#39;)

        self.time_min[i].insert(0, self.convert_time_to_date(self.bkg_start_time[i] + self.start_time))
        self.time_max[i].insert(0, self.convert_time_to_date(self.bkg_end_time[i] + self.start_time))

        self.bkg_start_index[i] = self.round_value(self.times, self.bkg_start_time[i])
        self.bkg_end_index[i] = self.round_value(self.times, self.bkg_end_time[i])

    def convert_time_to_date(self, time):
        &#34;&#34;&#34;Converts a time in seconds to a date at format YYYY-MM-DD-HH-MM-SS. \n
        Parameters: \n
            time: time to convert in sec. \n
        Returns: \n
            date: date at format YYYY-MM-DD-HH-MM-SS.&#34;&#34;&#34;
        days = int(self.date_day[2])
        hours = int(np.floor(time / 3600))
        minutes = int(np.floor((time / 3600 - hours) * 60))
        seconds = float(int((((time / 3600 - np.floor(time / 3600)) * 60) - minutes) * 60 * 1000) / 1000)

        # Delaying the day if observation if made on several days
        while hours &lt; 0 or hours &gt;= 24:
            diff_days = int(np.floor(hours / 24))
            hours -= diff_days * 24
            days += diff_days

        # Adding zeros to strings to have a better display
        if hours &lt; 10:
            hours = &#39;0&#39; + str(hours)
        if minutes &lt; 10:
            minutes = &#39;0&#39; + str(minutes)
        if seconds &lt; 10:
            seconds = &#39;0&#39; + str(seconds)
        if 100 * float(seconds) - np.floor(100 * float(seconds)) == 0:
            seconds = str(seconds) + &#39;0&#39;
            if 10 * float(seconds) - np.floor(10 * float(seconds)) == 0:
                seconds = str(seconds) + &#39;0&#39;

        return str(self.date_day[0]) + &#39;-&#39; + str(self.date_day[1]) + &#39;-&#39; + str(days) + &#39;T&#39; + str(hours) + &#39;:&#39; + \
            str(minutes) + &#39;:&#39; + str(seconds)

    def add_bands(self):
        &#34;&#34;&#34;Gets the values of plot limits from user choice.
        energy_min and energy_max are the Entry boxes for min and max energy bands defined in open_value.&#34;&#34;&#34;
        self.energies_low = []
        self.energies_high = []
        for i in range(int(self.nb_bands.get())):
            if self.energy_min[i].get() != &#39;&#39;:
                self.round_value(self.lower_bands, int(self.energy_min_list[i].get()))
                self.energies_low.append(int(self.energy_min_list[i].get()))

            if self.energy_max[i].get() != &#39;&#39;:
                self.round_value(self.upper_bands, int(self.energy_max_list[i].get()))
                self.energies_high.append(int(self.energy_max_list[i].get()))

    # =================== Plotting ===================

    def round_value(self, liste, value):
        &#34;&#34;&#34;Searches for the nearest number from the list. \n
        Parameters: \n
            liste: list where researched values are stored; \n
            value: number wanted to be rounded, to match one of the given list. \n
        Returns: \n
            index: index in the list of where the value has been found.&#34;&#34;&#34;
        index = 0
        near = np.abs(value - liste[0])
        self.rounded = int(value)
        for i in range(len(liste)):
            diff = np.abs(value - liste[i])
            if near &gt; diff:
                near = diff
                index = i
                self.rounded = int(liste[i])
        return index

    def get_data(self):
        &#34;&#34;&#34;Defines the Rate, Counts, and Flux for &#34;Plot Time Profile&#34;.&#34;&#34;&#34;
        self.data = np.zeros((len(self.times), len(self.energies_low) + 1))
        self.data_err = np.zeros(np.shape(self.data))

        # Determines the energy distribution for different channels relative to the time of observed data
        for i in range(len(self.times)):
            for j in range(len(self.energies_low) + 1):
                # Last column is self.times
                if j == len(self.energies_low):
                    self.data[i, j] = self.times[i]
                    self.data_err[i, j] = self.times[i]

                # Each column is the data for a band
                else:
                    if np.where(self.lower_bands == self.energies_low[j])[0]:
                        a = (np.where(self.lower_bands == self.energies_low[j]))[0][0]
                    else:
                        self.round_value(self.lower_bands, self.energies_low[j])
                        a = (np.where(self.lower_bands == self.rounded))[0][0]

                    if np.where(self.upper_bands == self.energies_high[j])[0]:
                        b = (np.where(self.upper_bands == self.energies_high[j]))[0][0]
                    else:
                        self.round_value(self.upper_bands, self.energies_high[j])
                        b = (np.where(self.upper_bands == self.rounded))[0][0]

                    # Transformaing data and error data according to unit type
                    if self.type == &#39;Rate&#39;:
                        self.data[i, j] = sum(self.counts[i, a:(b + 1)]) / self.del_times[i]
                        self.data_err[i, j] = sum(self.counts_err[i, a:(b + 1)]) / self.del_times[i]
                    elif self.type == &#39;Counts&#39;:
                        self.data[i, j] = sum(self.counts[i, a:(b + 1)])
                        self.data_err[i, j] = sum(self.counts_err[i, a:(b + 1)])
                    elif self.type == &#39;Flux&#39;:
                        e_diff = self.area * np.abs(self.energies_high[j] - self.energies_low[j])
                        self.data[i, j] = sum(self.counts[i, a:(b + 1)]) / self.del_times[i] / e_diff
                        self.data_err[i, j] = sum(self.counts_err[i, a:(b + 1)]) / self.del_times[i] / e_diff
                    else:
                        print(&#34;No matching unit plotting type found&#34;)

    def get_bkg(self):
        &#34;&#34;&#34;Plots the function of time by selected Unit. Uses the colormesh function provided by matplotlib library.&#34;&#34;&#34;
        self.bkg = np.zeros(np.shape(self.data))
        for band in range(len(self.energies_low) + 1):
            if band == len(self.energies_low):
                self.bkg[:, band] = self.times
            else:
                if self.var_sep_times.get() == 1:
                    if band != 0:
                        self.method_var[band].set(self.method_var[0].get())
                        self.method_list[band] = self.method_var[band]
                        self.bkg_start_index[band] = self.bkg_start_index[0]
                        self.bkg_end_index[band] = self.bkg_end_index[0]

                start = self.bkg_start_index[band]
                end = self.bkg_end_index[band]

                # Insert conditions on the method of calculation
                if self.method_list[band].get() == &#34;Median&#34;:
                    self.bkg[:, band] = np.median(self.data[start:end, band])

                elif self.method_list[band].get() == &#34;Mean&#34;:
                    self.bkg[:, band] = np.mean(self.data[start:end, band])

                elif self.method_list[band].get() == &#34;1Poly&#34;:
                    poly = np.poly1d(np.polyfit(self.times[start:end], self.data[start:end, band], 1))
                    for time in range(len(self.times)):
                        self.bkg[time, band] = poly(time)

                elif self.method_list[band].get() == &#34;2Poly&#34;:
                    poly = np.poly1d(np.polyfit(self.times[start:end], self.data[start:end, band], 2))
                    for time in range(len(self.times)):
                        self.bkg[time, band] = poly(time)

                elif self.method_list[band].get() == &#34;3Poly&#34;:
                    poly = np.poly1d(np.polyfit(self.times[start:end], self.data[start:end, band], 3))
                    for time in range(len(self.times)):
                        self.bkg[time, band] = poly(time)

                elif self.method_list[band].get() == &#34;Exp&#34;:
                    poly = np.polyfit(self.times[start:end], np.log(self.data[start:end, band]), 1)
                    for time in range(len(self.times)):
                        a = np.exp(poly[1])
                        b = poly[0]
                        self.bkg[time, band] = a * np.exp(b * self.times[time])

                else:
                    self.bkg[:, band] = 0
                    print(&#34;Background detection method not found&#34;)

                # Removing all negative values in the background
                for time in range(len(self.times)):
                    if self.bkg[time, band] &lt; 0:
                        self.bkg[time, band] = 0

    def get_data_bkg(self):
        &#34;&#34;&#34;Plots the function of time by selected Unit. Uses the colormesh function provided by matplotlib library.&#34;&#34;&#34;
        self.data_bkg = np.zeros(np.shape(self.data))
        for band in range(len(self.energies_low) + 1):
            if band == len(self.energies_low):
                self.data_bkg[:, band] = self.times
            else:
                for time in range(len(self.times)):
                    self.data_bkg[time, band] = self.data[time, band] - self.bkg[time, band]
                    if self.data_bkg[time, band] &lt; 0:
                        self.data_bkg[time, band] = 0

    def plot_options(self):
        &#34;&#34;&#34;Saves using matplotlib all options to plot the graph to later display it. \n
        Dependencies: time_profile_plotting&#34;&#34;&#34;
        # Absciss legend plot
        file_duration = max(self.times) - min(self.times)
        if file_duration &lt;= 1800:  # file duration less than 30 minutes
            step_x = 120
        elif file_duration &lt;= 3600:  # file duration less than 1 hour
            step_x = 480
        elif file_duration &lt;= 28800:  # file duration less than 8 hours
            step_x = 3600
        else:  # file duration more than 8 hours
            step_x = 7200

        self.time_scale = np.arange(0, file_duration, step_x)
        x_labels_plot = list(
            map(lambda x: (str(datetime.timedelta(seconds=x))).split(&#39;.&#39;)[0][:-3], self.time_scale +
                self.start_time))

        self.plot_label = []
        for i in range(len(x_labels_plot)):
            if &#39;day&#39; in x_labels_plot[i]:
                self.plot_label.append((x_labels_plot[i].split(&#39;,&#39;))[1])
            else:
                self.plot_label.append(x_labels_plot[i])

        self.xlabel = &#39;Start time: &#39; + str(self.start_date) + &#39; -- End time : &#39; + str(self.end_date)

        # Unit plotting
        if self.type == &#34;Rate&#34;:
            self.ylabel = &#39;Rate (Counts/s) by Bands&#39;
            self.title = &#39;Time Profile Plotting Rate (Counts/s)&#39;

        elif self.type == &#34;Counts&#34;:
            self.ylabel = &#39;Counts by Bands&#39;
            self.title = &#39;Time Profile Plotting Counts&#39;

        elif self.type == &#34;Flux&#34;:
            self.ylabel = &#39;Flux by Bands&#39;
            self.title = &#39;Time Profile Plotting Flux&#39;

        else:
            print(&#34;No matching unit plotting type found&#34;)

        # Labeling energy bands on the plot
        self.data_label = []
        for data_type in [&#39;Original data&#39;, &#39;Background&#39;, &#39;Corrected data&#39;]:
            label = [data_type + &#39; for &#39; + str(low) + &#39;-&#39; + str(high) + &#39;keV&#39; for low, high in
                     zip(self.energies_low, self.energies_high)]
            label.append(&#39;Times&#39;)
            self.data_label.append(label)

    def time_profile_plotting(self):
        &#34;&#34;&#34;Calls for all previous functions to get all data needed, then show the plot.
        Dependencies: get_data, get_bkg, get_data_bkg, plot_options&#34;&#34;&#34;
        plt.close()
        self.add_bands()
        self.type = self.unit_var.get()
        self.get_data()
        plt.figure()
        self.plot_options()

        # Plotting data
        if self.var_error.get():
            yerr = self.data_err
        else:
            yerr = np.zeros(np.shape(self.data_err))

        if self.var_og_data.get():
            df = pd.DataFrame(self.data, index=self.times, columns=self.data_label[0])
            for band in range(len(self.energies_low)):
                df.plot(x=&#39;Times&#39;, y=self.data_label[0][band], yerr=yerr[:, band], color=self.color[band],
                        ax=plt.gca(), linewidth=0.25)

        if self.var_bkg.get() or self.var_data_bkg.get():
            self.get_bkg()

            if self.var_bkg.get():
                df = pd.DataFrame(self.bkg, index=self.times, columns=self.data_label[1])
                for band in range(len(self.energies_low)):
                    df.plot(x=&#39;Times&#39;, y=self.data_label[1][band], color=self.color[band],
                            ax=plt.gca(), linewidth=0.1)

            if self.var_data_bkg.get():
                self.get_data_bkg()
                df = pd.DataFrame(self.data_bkg, index=self.times, columns=self.data_label[2])
                for band in range(len(self.energies_low)):
                    df.plot(x=&#39;Times&#39;, y=self.data_label[2][band], yerr=yerr[:, band], color=self.color[band],
                            ax=plt.gca(), linewidth=1)

        plt.xticks(self.time_scale, self.plot_label)
        plt.xlabel(self.xlabel)
        plt.ylabel(self.ylabel)
        plt.title(self.title)
        plt.show()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="background.BackgroundWindow.fname"><code class="name">var <span class="ident">fname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="background.BackgroundWindow.delay_times"><code class="name flex">
<span>def <span class="ident">delay_times</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a TEMPORARY -1 interval, because of the step between deltimes data. Returns the shifted data. </p>
<p>Parameters: </p>
<pre><code>data: original data.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def delay_times(data):
    &#34;&#34;&#34;Creates a TEMPORARY -1 interval, because of the step between deltimes data. Returns the shifted data. \n
    Parameters: \n
        data: original data.&#34;&#34;&#34;
    del_data = np.zeros_like(data)
    for i in range(1, len(data)):
        del_data[i] = data[i - 1]
    del_data[0] = data[0]
    return del_data</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the Data and Header contents from input file. Loads the input file choosen in 'Select Input' section.
Returns respectively a table containing datas, energies, dates and channels.</p>
<p>Parameters: </p>
<pre><code>file: contains the data in a fits file.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_data(file):
    &#34;&#34;&#34;Reads the Data and Header contents from input file. Loads the input file choosen in &#39;Select Input&#39; section.
    Returns respectively a table containing datas, energies, dates and channels.\n
    Parameters: \n
        file: contains the data in a fits file.&#34;&#34;&#34;
    hdulist = fits.open(file)   # Reads the data
    hdulist.info()              # Displays the content of the read file
    return hdulist[2].data, hdulist[3].data, hdulist[0].header, hdulist[3].header</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="background.BackgroundWindow.add_bands"><code class="name flex">
<span>def <span class="ident">add_bands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the values of plot limits from user choice.
energy_min and energy_max are the Entry boxes for min and max energy bands defined in open_value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_bands(self):
    &#34;&#34;&#34;Gets the values of plot limits from user choice.
    energy_min and energy_max are the Entry boxes for min and max energy bands defined in open_value.&#34;&#34;&#34;
    self.energies_low = []
    self.energies_high = []
    for i in range(int(self.nb_bands.get())):
        if self.energy_min[i].get() != &#39;&#39;:
            self.round_value(self.lower_bands, int(self.energy_min_list[i].get()))
            self.energies_low.append(int(self.energy_min_list[i].get()))

        if self.energy_max[i].get() != &#39;&#39;:
            self.round_value(self.upper_bands, int(self.energy_max_list[i].get()))
            self.energies_high.append(int(self.energy_max_list[i].get()))</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.build_bkg_window"><code class="name flex">
<span>def <span class="ident">build_bkg_window</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds the main components of the background window and the first frame; waits for the user to choose a file
to build the second frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_bkg_window(self):
    &#34;&#34;&#34;Builds the main components of the background window and the first frame; waits for the user to choose a file
    to build the second frame.&#34;&#34;&#34;

    # =================== Window definition ===================

    self.bkg_window = Toplevel()
    self.bkg_window.title(&#39;STIX Background Options&#39;)
    self.bkg_window.geometry(&#34;1000x600&#34;)
    Label(self.bkg_window,
          text=&#34;Select Background&#34;,
          fg=&#34;black&#34;,
          font=&#34;Helvetica 12 bold italic&#34;).pack()

    self.close = Button(self.bkg_window, text=&#34;Close&#34;, command=self.destroy)
    self.close.place(relx=0.5, rely=0.95, anchor=&#39;center&#39;)

    # =================== 1st frame : Data &amp; Unit Plotting ===================

    self.frame1 = LabelFrame(self.bkg_window, relief=RAISED, borderwidth=2)
    self.frame1.place(relx=0.025, rely=0.05, relheight=0.15, relwidth=0.95)

    self.label_filename = Label(self.frame1, text=&#34;Spectrum or Image File: &#34;)
    self.label_filename.place(relx=0.02, rely=0.25, anchor=W)
    self.text_filename = Entry(self.frame1, width=20)
    self.text_filename.place(relx=0.19, rely=0.25, relheight=0.3, relwidth=0.57, anchor=W)
    if BackgroundWindow.fname:
        self.text_filename.insert(0, BackgroundWindow.fname)
        self.open_file(BackgroundWindow.fname)
    else:
        self.text_filename.insert(0, &#34;No file chosen&#34;)

    self.btn_browse = Button(self.frame1, text=&#39;Browse -&gt;&#39;, command=self.open_file)
    self.btn_browse.place(relx=0.78, rely=0.25, anchor=W)

    self.label1 = Label(self.frame1, text=&#34;Plot time profile for: &#34;)
    self.label1.place(relx=0.02, rely=0.65, anchor=W)

    self.btn_og_data = Checkbutton(self.frame1, text=&#34;Data&#34;, variable=self.var_og_data)
    self.btn_og_data.place(relx=0.19, rely=0.65, anchor=W)

    self.btn_bkg = Checkbutton(self.frame1, text=&#34;Background&#34;, variable=self.var_bkg, command=self.disable_bkg)
    self.btn_bkg.place(relx=0.26, rely=0.65, anchor=W)

    self.btn_data_bkg = Checkbutton(self.frame1, text=&#34;Data-Background&#34;, variable=self.var_data_bkg,
                                    command=self.disable_bkg)
    self.btn_data_bkg.place(relx=0.37, rely=0.65, anchor=W)

    self.btn_error = Checkbutton(self.frame1, text=&#34;Error&#34;, variable=self.var_error)
    self.btn_error.place(relx=0.51, rely=0.65, anchor=W)</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.build_other_frames"><code class="name flex">
<span>def <span class="ident">build_other_frames</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Builds third, fourth and fifth frames. Buttons call for their respective functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_other_frames(self, *args):
    &#34;&#34;&#34;Builds third, fourth and fifth frames. Buttons call for their respective functions.&#34;&#34;&#34;

    # =================== 3rd frame : Energy Interval Selection ===================

    self.frame3 = Frame(self.bkg_window, relief=RAISED, borderwidth=2)
    self.frame3.place(relx=0.175, rely=0.2, relheight=0.3, relwidth=0.80)

    self.text_min_energy = Label(self.frame3, text=&#34;Min energy&#34;)
    self.text_min_energy.place(relx=0.375, rely=0.18, anchor=&#34;center&#34;)
    self.text_max_energy = Label(self.frame3, text=&#34;Max energy&#34;)
    self.text_max_energy.place(relx=0.625, rely=0.18, anchor=&#34;center&#34;)

    # =================== 4th frame : Time Interval Selection ===================

    self.frame4 = Frame(self.bkg_window, relief=RAISED, borderwidth=2)
    self.frame4.place(relx=0.025, rely=0.5, relheight=0.3, relwidth=0.95)

    self.label4 = Label(self.frame4, text=&#34;Time interval selection for background noise: &#34;)
    self.label4.place(relx=0.01, rely=0.05)

    self.btn_sep_times = Checkbutton(self.frame4, text=&#34;Same time interval for all bands&#34;,
                                     variable=self.var_sep_times, command=self.disable_times,
                                     state=self.state_bkg)
    self.btn_sep_times.place(relx=0.95, rely=0.01, anchor=NE)

    self.text_start_time = Label(self.frame4, text=&#34;Start time&#34;)
    self.text_start_time.place(relx=0.2, rely=0.16, anchor=N)
    self.text_end_time = Label(self.frame4, text=&#34;End time&#34;)
    self.text_end_time.place(relx=0.4, rely=0.16, anchor=N)

    self.text_noise = Label(self.frame4, text=&#34;Method for noise calculation: &#34;)
    self.text_noise.place(relx=0.85, rely=0.16, anchor=N)

    # =================== 5th frame : Plot Units ===================

    self.frame5 = LabelFrame(self.bkg_window, relief=RAISED, borderwidth=2)
    self.frame5.place(relx=0.025, rely=0.8, relheight=0.1, relwidth=0.95)

    self.label5 = Label(self.frame5, text=&#34;Plot units: &#34;)
    self.label5.place(relx=0.01, rely=0.5, anchor=W)

    self.unit_var = StringVar(self.frame5)
    self.unit_var.set(self.unit_choices[0])
    self.type = self.unit_var.get()
    self.menu_units = OptionMenu(self.frame5, self.unit_var, *self.unit_choices)
    self.menu_units.place(relx=0.1, rely=0.5, anchor=W)

    self.btn_time_profile_plotting = Button(self.frame5, text=&#34;Plot Time Profile&#34;,
                                            command=self.time_profile_plotting)
    self.btn_time_profile_plotting.place(relx=0.3, rely=0.5, anchor=&#34;center&#34;)

    # ============== Entries for frames 3 &amp; 4 ==============

    self.entries_list()</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.build_second_frame"><code class="name flex">
<span>def <span class="ident">build_second_frame</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>After selecting the file, builds the second frame, containing a list with the number of energy bands;
waits for the user to select the number of bands to build the other frames.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_second_frame(self):
    &#34;&#34;&#34;After selecting the file, builds the second frame, containing a list with the number of energy bands;
    waits for the user to select the number of bands to build the other frames.&#34;&#34;&#34;

    # =================== 2nd frame : Number of Bands Selection ===================

    self.frame2 = Canvas(self.bkg_window, relief=RAISED, borderwidth=2)
    self.frame2.place(relx=0.025, rely=0.2, relheight=0.3, relwidth=0.15)

    self.label2 = Label(self.frame2, text=&#34;Energy bands selection: &#34;)
    self.label2.place(relx=0.5, rely=0.05, anchor=N)

    self.nb_bands = StringVar(self.frame2)
    self.nb_bands.set(&#39;-&#39;)
    self.choice_bands = OptionMenu(self.frame2, self.nb_bands, *self.list_bands)
    self.choice_bands.place(relx=0.5, rely=0.20, anchor=N)
    self.nb_bands.trace(&#34;w&#34;, self.build_other_frames)</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.convert_time_to_date"><code class="name flex">
<span>def <span class="ident">convert_time_to_date</span></span>(<span>self, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a time in seconds to a date at format YYYY-MM-DD-HH-MM-SS. </p>
<p>Parameters: </p>
<pre><code>time: time to convert in sec.
</code></pre>
<p>Returns: </p>
<pre><code>date: date at format YYYY-MM-DD-HH-MM-SS.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_time_to_date(self, time):
    &#34;&#34;&#34;Converts a time in seconds to a date at format YYYY-MM-DD-HH-MM-SS. \n
    Parameters: \n
        time: time to convert in sec. \n
    Returns: \n
        date: date at format YYYY-MM-DD-HH-MM-SS.&#34;&#34;&#34;
    days = int(self.date_day[2])
    hours = int(np.floor(time / 3600))
    minutes = int(np.floor((time / 3600 - hours) * 60))
    seconds = float(int((((time / 3600 - np.floor(time / 3600)) * 60) - minutes) * 60 * 1000) / 1000)

    # Delaying the day if observation if made on several days
    while hours &lt; 0 or hours &gt;= 24:
        diff_days = int(np.floor(hours / 24))
        hours -= diff_days * 24
        days += diff_days

    # Adding zeros to strings to have a better display
    if hours &lt; 10:
        hours = &#39;0&#39; + str(hours)
    if minutes &lt; 10:
        minutes = &#39;0&#39; + str(minutes)
    if seconds &lt; 10:
        seconds = &#39;0&#39; + str(seconds)
    if 100 * float(seconds) - np.floor(100 * float(seconds)) == 0:
        seconds = str(seconds) + &#39;0&#39;
        if 10 * float(seconds) - np.floor(10 * float(seconds)) == 0:
            seconds = str(seconds) + &#39;0&#39;

    return str(self.date_day[0]) + &#39;-&#39; + str(self.date_day[1]) + &#39;-&#39; + str(days) + &#39;T&#39; + str(hours) + &#39;:&#39; + \
        str(minutes) + &#39;:&#39; + str(seconds)</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Closing 'Select Input' window when clicking 'Close' button.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34;Closing &#39;Select Input&#39; window when clicking &#39;Close&#39; button.&#34;&#34;&#34;
    self.bkg_window.destroy()</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.disable_bkg"><code class="name flex">
<span>def <span class="ident">disable_bkg</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If none of the checkboxes "Background" and "Data-Background" are ticked, disables all buttons in frame 4;
else, enables them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_bkg(self):
    &#34;&#34;&#34;If none of the checkboxes &#34;Background&#34; and &#34;Data-Background&#34; are ticked, disables all buttons in frame 4;
    else, enables them.&#34;&#34;&#34;

    # If the user (un)selects background or data-background for the plot, enales or disables all background options
    if self.var_bkg.get() + self.var_data_bkg.get() &lt; 2 and self.backup_bkg &lt; 2:
        if self.state_bkg == NORMAL:
            if self.frame4:
                for i in range(int(self.nb_bands.get())):
                    self.time_min[i].delete(0, &#39;end&#39;)
                    self.time_max[i].delete(0, &#39;end&#39;)
                self.btn_sep_times.select()
            self.state_bkg = DISABLED
            self.state_time = DISABLED
        else:
            self.state_bkg = NORMAL
            if self.frame4:
                for i in range(int(self.nb_bands.get())):
                    self.time_min[i].insert(0, self.start_date)
                    self.time_max[i].insert(0, self.end_date)

    # If background frames have been built:
    if self.frame4:
        self.btn_sep_times.config(state=self.state_bkg)
        self.time_min[0].config(state=self.state_bkg)
        self.time_max[0].config(state=self.state_bkg)
        self.btn_graphical[0].config(state=self.state_bkg)
        self.method_selection[0].config(state=self.state_bkg)
        for i in range(1, int(self.nb_bands.get())):
            self.time_min[i].config(state=self.state_time)
            self.time_max[i].config(state=self.state_time)
            self.btn_graphical[i].config(state=self.state_time)
            self.method_selection[i].config(state=self.state_time)

        if self.time_min[0].get() == &#39;&#39;:
            self.time_min[0].insert(0, self.start_date)
        if self.time_max[0].get() == &#39;&#39;:
            self.time_max[0].insert(0, self.end_date)

    # Backup variable is used to compare old state of background checkboxes;
    # So if user ticks both background &amp; data-background, background frames will remain active.
    self.backup_bkg = self.var_bkg.get() + self.var_data_bkg.get()</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.disable_times"><code class="name flex">
<span>def <span class="ident">disable_times</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows user to set different time intervals for each band for background calculation. If the checkbutton
"Same time interval for all bands" is ticked, disables all buttons in frame 4, except for the first band;
else, enables all other buttons in frame 4.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_times(self):
    &#34;&#34;&#34;Allows user to set different time intervals for each band for background calculation. If the checkbutton
    &#34;Same time interval for all bands&#34; is ticked, disables all buttons in frame 4, except for the first band;
    else, enables all other buttons in frame 4.&#34;&#34;&#34;

    if self.state_time == NORMAL:
        self.state_time = DISABLED
        for i in range(1, int(self.nb_bands.get())):
            self.time_min[i].delete(0, &#39;end&#39;)
            self.time_max[i].delete(0, &#39;end&#39;)
    else:
        self.state_time = NORMAL
        for i in range(1, int(self.nb_bands.get())):
            self.time_min[i].insert(0, self.start_date)
            self.time_max[i].insert(0, self.end_date)

    for i in range(1, int(self.nb_bands.get())):
        self.time_min[i].config(state=self.state_time)
        self.time_max[i].config(state=self.state_time)
        self.btn_graphical[i].config(state=self.state_time)
        self.method_selection[i].config(state=self.state_time)

        if self.time_min[i].get() == &#39;&#39;:
            self.time_min[i].insert(0, self.start_date)
        if self.time_max[i].get() == &#39;&#39;:
            self.time_max[i].insert(0, self.end_date)</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.entries_list"><code class="name flex">
<span>def <span class="ident">entries_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows to create all buttons and Entry boxes to choose energy values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def entries_list(self):
    &#34;&#34;&#34;Allows to create all buttons and Entry boxes to choose energy values.&#34;&#34;&#34;
    if self.nb_bands.get().isdigit():
        self.energy_min = [&#39;&#39;] * int(self.nb_bands.get())
        self.energy_max = [&#39;&#39;] * int(self.nb_bands.get())
        self.energy_min_list = [&#39;&#39;] * int(self.nb_bands.get())
        self.energy_max_list = [&#39;&#39;] * int(self.nb_bands.get())

        self.time_min = [&#39;&#39;] * int(self.nb_bands.get())
        self.time_max = [&#39;&#39;] * int(self.nb_bands.get())
        self.time_min_list = [&#39;&#39;] * int(self.nb_bands.get())
        self.time_max_list = [&#39;&#39;] * int(self.nb_bands.get())

        self.bkg_start_time = [&#39;&#39;] * int(self.nb_bands.get())
        self.bkg_end_time = [&#39;&#39;] * int(self.nb_bands.get())
        self.bkg_start_index = [&#39;&#39;] * int(self.nb_bands.get())
        self.bkg_end_index = [&#39;&#39;] * int(self.nb_bands.get())

        self.method_selection = [&#39;&#39;] * int(self.nb_bands.get())
        self.method_list = [&#39;&#39;] * int(self.nb_bands.get())

        self.btn_graphical = [&#39;&#39;] * int(self.nb_bands.get())

        for i in range(int(self.nb_bands.get())):
            self.method_var.append(StringVar(self.frame3))
            self.method_var[i].set(self.method_choices[1])

            # Getting values for each band
            self.open_value(i)

            self.energy_min_list[i] = self.energy_min[i]
            self.energy_max_list[i] = self.energy_max[i]

            self.time_min_list[i] = self.time_min[i]
            self.time_max_list[i] = self.time_max[i]

            self.method_list[i] = self.method_var[i]</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.find_time"><code class="name flex">
<span>def <span class="ident">find_time</span></span>(<span>self, date)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the starting time in the data. </p>
<p>Parameters: </p>
<pre><code>date: starting date as a list.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_time(self, date):
    &#34;&#34;&#34;Converts the starting time in the data. \n
    Parameters: \n
        date: starting date as a list.&#34;&#34;&#34;
    date_split = re.split(&#39;T&#39;, date)
    self.date_day = re.split(&#39;-&#39;, date_split[0])
    self.date_time = re.split(&#39;:&#39;, date_split[1])
    int_time_sec = re.split(&#39;\\.&#39;, self.date_time[2])
    found_time = (int(self.date_time[0]), int(self.date_time[1]), int(int_time_sec[0]))
    return found_time</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.get_bkg"><code class="name flex">
<span>def <span class="ident">get_bkg</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the function of time by selected Unit. Uses the colormesh function provided by matplotlib library.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bkg(self):
    &#34;&#34;&#34;Plots the function of time by selected Unit. Uses the colormesh function provided by matplotlib library.&#34;&#34;&#34;
    self.bkg = np.zeros(np.shape(self.data))
    for band in range(len(self.energies_low) + 1):
        if band == len(self.energies_low):
            self.bkg[:, band] = self.times
        else:
            if self.var_sep_times.get() == 1:
                if band != 0:
                    self.method_var[band].set(self.method_var[0].get())
                    self.method_list[band] = self.method_var[band]
                    self.bkg_start_index[band] = self.bkg_start_index[0]
                    self.bkg_end_index[band] = self.bkg_end_index[0]

            start = self.bkg_start_index[band]
            end = self.bkg_end_index[band]

            # Insert conditions on the method of calculation
            if self.method_list[band].get() == &#34;Median&#34;:
                self.bkg[:, band] = np.median(self.data[start:end, band])

            elif self.method_list[band].get() == &#34;Mean&#34;:
                self.bkg[:, band] = np.mean(self.data[start:end, band])

            elif self.method_list[band].get() == &#34;1Poly&#34;:
                poly = np.poly1d(np.polyfit(self.times[start:end], self.data[start:end, band], 1))
                for time in range(len(self.times)):
                    self.bkg[time, band] = poly(time)

            elif self.method_list[band].get() == &#34;2Poly&#34;:
                poly = np.poly1d(np.polyfit(self.times[start:end], self.data[start:end, band], 2))
                for time in range(len(self.times)):
                    self.bkg[time, band] = poly(time)

            elif self.method_list[band].get() == &#34;3Poly&#34;:
                poly = np.poly1d(np.polyfit(self.times[start:end], self.data[start:end, band], 3))
                for time in range(len(self.times)):
                    self.bkg[time, band] = poly(time)

            elif self.method_list[band].get() == &#34;Exp&#34;:
                poly = np.polyfit(self.times[start:end], np.log(self.data[start:end, band]), 1)
                for time in range(len(self.times)):
                    a = np.exp(poly[1])
                    b = poly[0]
                    self.bkg[time, band] = a * np.exp(b * self.times[time])

            else:
                self.bkg[:, band] = 0
                print(&#34;Background detection method not found&#34;)

            # Removing all negative values in the background
            for time in range(len(self.times)):
                if self.bkg[time, band] &lt; 0:
                    self.bkg[time, band] = 0</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the Rate, Counts, and Flux for "Plot Time Profile".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data(self):
    &#34;&#34;&#34;Defines the Rate, Counts, and Flux for &#34;Plot Time Profile&#34;.&#34;&#34;&#34;
    self.data = np.zeros((len(self.times), len(self.energies_low) + 1))
    self.data_err = np.zeros(np.shape(self.data))

    # Determines the energy distribution for different channels relative to the time of observed data
    for i in range(len(self.times)):
        for j in range(len(self.energies_low) + 1):
            # Last column is self.times
            if j == len(self.energies_low):
                self.data[i, j] = self.times[i]
                self.data_err[i, j] = self.times[i]

            # Each column is the data for a band
            else:
                if np.where(self.lower_bands == self.energies_low[j])[0]:
                    a = (np.where(self.lower_bands == self.energies_low[j]))[0][0]
                else:
                    self.round_value(self.lower_bands, self.energies_low[j])
                    a = (np.where(self.lower_bands == self.rounded))[0][0]

                if np.where(self.upper_bands == self.energies_high[j])[0]:
                    b = (np.where(self.upper_bands == self.energies_high[j]))[0][0]
                else:
                    self.round_value(self.upper_bands, self.energies_high[j])
                    b = (np.where(self.upper_bands == self.rounded))[0][0]

                # Transformaing data and error data according to unit type
                if self.type == &#39;Rate&#39;:
                    self.data[i, j] = sum(self.counts[i, a:(b + 1)]) / self.del_times[i]
                    self.data_err[i, j] = sum(self.counts_err[i, a:(b + 1)]) / self.del_times[i]
                elif self.type == &#39;Counts&#39;:
                    self.data[i, j] = sum(self.counts[i, a:(b + 1)])
                    self.data_err[i, j] = sum(self.counts_err[i, a:(b + 1)])
                elif self.type == &#39;Flux&#39;:
                    e_diff = self.area * np.abs(self.energies_high[j] - self.energies_low[j])
                    self.data[i, j] = sum(self.counts[i, a:(b + 1)]) / self.del_times[i] / e_diff
                    self.data_err[i, j] = sum(self.counts_err[i, a:(b + 1)]) / self.del_times[i] / e_diff
                else:
                    print(&#34;No matching unit plotting type found&#34;)</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.get_data_bkg"><code class="name flex">
<span>def <span class="ident">get_data_bkg</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the function of time by selected Unit. Uses the colormesh function provided by matplotlib library.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_bkg(self):
    &#34;&#34;&#34;Plots the function of time by selected Unit. Uses the colormesh function provided by matplotlib library.&#34;&#34;&#34;
    self.data_bkg = np.zeros(np.shape(self.data))
    for band in range(len(self.energies_low) + 1):
        if band == len(self.energies_low):
            self.data_bkg[:, band] = self.times
        else:
            for time in range(len(self.times)):
                self.data_bkg[time, band] = self.data[time, band] - self.bkg[time, band]
                if self.data_bkg[time, band] &lt; 0:
                    self.data_bkg[time, band] = 0</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.graphical_interval"><code class="name flex">
<span>def <span class="ident">graphical_interval</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls for interval_selection.py to plot data graph. Time interval can directly be chosen on the graph.
Stores starting and ending times in two lists. Dependencies: interval_selection.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graphical_interval(self, i):
    &#34;&#34;&#34;Calls for interval_selection.py to plot data graph. Time interval can directly be chosen on the graph.
    Stores starting and ending times in two lists. Dependencies: interval_selection.py&#34;&#34;&#34;
    self.type = self.unit_var.get()
    self.add_bands()
    self.get_data()
    self.plot_options()

    self.bkg_start_time[i], self.bkg_end_time[i] = \
        IntervalSelector(self.times, self.data,
                         x_scale=self.time_scale,
                         plot_label=self.plot_label,
                         col_label=self.data_label,
                         title=self.title,
                         xlabel=self.xlabel,
                         ylabel=self.ylabel,
                         color=self.color,
                         samefig=self.var_sep_times.get(),
                         band=i).graphical_selection()

    if self.bkg_start_time[i] &lt; 0:
        self.bkg_start_time[i] = 0
    if self.bkg_end_time[i] &gt; self.end_time - self.start_time:
        self.bkg_end_time[i] = self.end_time - self.start_time

    self.time_min[i].delete(0, &#39;end&#39;)
    self.time_max[i].delete(0, &#39;end&#39;)

    self.time_min[i].insert(0, self.convert_time_to_date(self.bkg_start_time[i] + self.start_time))
    self.time_max[i].insert(0, self.convert_time_to_date(self.bkg_end_time[i] + self.start_time))

    self.bkg_start_index[i] = self.round_value(self.times, self.bkg_start_time[i])
    self.bkg_end_index[i] = self.round_value(self.times, self.bkg_end_time[i])</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.open_file"><code class="name flex">
<span>def <span class="ident">open_file</span></span>(<span>self, file=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the input data using Astropy library. It can be any extension. RHESSI .fits files are analysed. </p>
<p>Parameters: </p>
<pre><code>file: if a file has already been opened previously (i.e. in background), automatically re-reads it instead
of asking user to choose it again.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_file(self, file=None):
    &#34;&#34;&#34;Reads the input data using Astropy library. It can be any extension. RHESSI .fits files are analysed. \n
    Parameters: \n
        file: if a file has already been opened previously (i.e. in background), automatically re-reads it instead
        of asking user to choose it again.&#34;&#34;&#34;
    if file:
        self.name = file
    else:
        self.name = askopenfilename(initialdir=&#34;.&#34;,
                                    filetypes=((&#34;FITS files&#34;, &#34;*.fits&#34;), (&#34;All Files&#34;, &#34;*.*&#34;)),
                                    title=&#34;Please Select Spectrum or Image File&#34;)
    self.text_filename.delete(0, &#39;end&#39;)
    BackgroundWindow.fname = self.name

    if self.name:  # If file has been chosen by user
        with fits.open(self.name) as hdul:
            self.hdul = hdul

            # Loads headers informations
            time_summarize = [self.hdul[2].data.time[-1], self.hdul[0].header[19],
                              self.hdul[0].header[21]]  # time data
            self.start_date, self.end_date = time_summarize[1], time_summarize[2]
            self.text_filename.insert(0, self.name)  # Displays the input file name in Entry box
            self.lower_bands = np.array(self.hdul[3].data.e_low)
            self.upper_bands = np.array(self.hdul[3].data.e_high)

        # Loading data
        data1, data2, header0, header1 = self.load_data(self.name)
        self.times = data1.time
        self.counts = data1.counts
        self.counts_err = data1.counts_err

        self.del_times = self.delay_times(data1.timedel)

        start_time = self.find_time(self.start_date)
        end_time = self.find_time(self.end_date)
        self.start_time = start_time[0] * 3600 + start_time[1] * 60 + start_time[2]
        self.end_time = end_time[0] * 3600 + end_time[1] * 60 + end_time[2]

        # Importing plotting.py with self.name now chosen
        self.build_second_frame()
    else:
        self.text_filename.insert(0, &#34;No file chosen&#34;)</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.open_value"><code class="name flex">
<span>def <span class="ident">open_value</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates entry boxes to let the user choose the limits of the plot.
Dependencies: entry_int.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_value(self, i):
    &#34;&#34;&#34;Creates entry boxes to let the user choose the limits of the plot.
    Dependencies: entry_int.py&#34;&#34;&#34;
    self.energy_min[i] = EntryInt(self.frame3, width=20)
    self.energy_max[i] = EntryInt(self.frame3, width=20)

    self.energy_min[i].place(relx=0.375, rely=0.27 + 0.14 * i, anchor=N)
    self.energy_max[i].place(relx=0.625, rely=0.27 + 0.14 * i, anchor=N)

    self.time_min[i] = Entry(self.frame4, width=20, state=self.state_time)
    self.time_max[i] = Entry(self.frame4, width=20, state=self.state_time)

    self.time_min[i].place(relx=0.2, rely=0.3 + 0.14 * i, anchor=N, width=150)
    self.time_max[i].place(relx=0.4, rely=0.3 + 0.14 * i, anchor=N, width=150)

    self.time_min[i].insert(0, self.start_date)
    self.time_max[i].insert(0, self.end_date)

    self.bkg_start_index[i] = 0
    self.bkg_end_index[i] = len(self.times)

    self.btn_graphical[i] = Button(self.frame4, text=&#34;Graphical&#34;, state=self.state_time,
                                   command=lambda: self.graphical_interval(i))
    self.btn_graphical[i].place(relx=0.6, rely=0.35 + 0.14 * i, anchor=W)

    self.method_selection[i] = OptionMenu(self.frame4, self.method_var[i], *self.method_choices)
    self.method_selection[i].place(relx=0.85, rely=0.35 + 0.14 * i, anchor=&#34;center&#34;)
    self.method_selection[i].config(state=self.state_time)

    self.time_min[0].config(state=self.state_bkg)
    self.time_max[0].config(state=self.state_bkg)
    self.btn_graphical[0].config(state=self.state_bkg)
    self.method_selection[0].config(state=self.state_bkg)</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.plot_options"><code class="name flex">
<span>def <span class="ident">plot_options</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves using matplotlib all options to plot the graph to later display it. </p>
<p>Dependencies: time_profile_plotting</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_options(self):
    &#34;&#34;&#34;Saves using matplotlib all options to plot the graph to later display it. \n
    Dependencies: time_profile_plotting&#34;&#34;&#34;
    # Absciss legend plot
    file_duration = max(self.times) - min(self.times)
    if file_duration &lt;= 1800:  # file duration less than 30 minutes
        step_x = 120
    elif file_duration &lt;= 3600:  # file duration less than 1 hour
        step_x = 480
    elif file_duration &lt;= 28800:  # file duration less than 8 hours
        step_x = 3600
    else:  # file duration more than 8 hours
        step_x = 7200

    self.time_scale = np.arange(0, file_duration, step_x)
    x_labels_plot = list(
        map(lambda x: (str(datetime.timedelta(seconds=x))).split(&#39;.&#39;)[0][:-3], self.time_scale +
            self.start_time))

    self.plot_label = []
    for i in range(len(x_labels_plot)):
        if &#39;day&#39; in x_labels_plot[i]:
            self.plot_label.append((x_labels_plot[i].split(&#39;,&#39;))[1])
        else:
            self.plot_label.append(x_labels_plot[i])

    self.xlabel = &#39;Start time: &#39; + str(self.start_date) + &#39; -- End time : &#39; + str(self.end_date)

    # Unit plotting
    if self.type == &#34;Rate&#34;:
        self.ylabel = &#39;Rate (Counts/s) by Bands&#39;
        self.title = &#39;Time Profile Plotting Rate (Counts/s)&#39;

    elif self.type == &#34;Counts&#34;:
        self.ylabel = &#39;Counts by Bands&#39;
        self.title = &#39;Time Profile Plotting Counts&#39;

    elif self.type == &#34;Flux&#34;:
        self.ylabel = &#39;Flux by Bands&#39;
        self.title = &#39;Time Profile Plotting Flux&#39;

    else:
        print(&#34;No matching unit plotting type found&#34;)

    # Labeling energy bands on the plot
    self.data_label = []
    for data_type in [&#39;Original data&#39;, &#39;Background&#39;, &#39;Corrected data&#39;]:
        label = [data_type + &#39; for &#39; + str(low) + &#39;-&#39; + str(high) + &#39;keV&#39; for low, high in
                 zip(self.energies_low, self.energies_high)]
        label.append(&#39;Times&#39;)
        self.data_label.append(label)</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.round_value"><code class="name flex">
<span>def <span class="ident">round_value</span></span>(<span>self, liste, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for the nearest number from the list. </p>
<p>Parameters: </p>
<pre><code>liste: list where researched values are stored;

value: number wanted to be rounded, to match one of the given list.
</code></pre>
<p>Returns: </p>
<pre><code>index: index in the list of where the value has been found.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_value(self, liste, value):
    &#34;&#34;&#34;Searches for the nearest number from the list. \n
    Parameters: \n
        liste: list where researched values are stored; \n
        value: number wanted to be rounded, to match one of the given list. \n
    Returns: \n
        index: index in the list of where the value has been found.&#34;&#34;&#34;
    index = 0
    near = np.abs(value - liste[0])
    self.rounded = int(value)
    for i in range(len(liste)):
        diff = np.abs(value - liste[i])
        if near &gt; diff:
            near = diff
            index = i
            self.rounded = int(liste[i])
    return index</code></pre>
</details>
</dd>
<dt id="background.BackgroundWindow.time_profile_plotting"><code class="name flex">
<span>def <span class="ident">time_profile_plotting</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls for all previous functions to get all data needed, then show the plot.
Dependencies: get_data, get_bkg, get_data_bkg, plot_options</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_profile_plotting(self):
    &#34;&#34;&#34;Calls for all previous functions to get all data needed, then show the plot.
    Dependencies: get_data, get_bkg, get_data_bkg, plot_options&#34;&#34;&#34;
    plt.close()
    self.add_bands()
    self.type = self.unit_var.get()
    self.get_data()
    plt.figure()
    self.plot_options()

    # Plotting data
    if self.var_error.get():
        yerr = self.data_err
    else:
        yerr = np.zeros(np.shape(self.data_err))

    if self.var_og_data.get():
        df = pd.DataFrame(self.data, index=self.times, columns=self.data_label[0])
        for band in range(len(self.energies_low)):
            df.plot(x=&#39;Times&#39;, y=self.data_label[0][band], yerr=yerr[:, band], color=self.color[band],
                    ax=plt.gca(), linewidth=0.25)

    if self.var_bkg.get() or self.var_data_bkg.get():
        self.get_bkg()

        if self.var_bkg.get():
            df = pd.DataFrame(self.bkg, index=self.times, columns=self.data_label[1])
            for band in range(len(self.energies_low)):
                df.plot(x=&#39;Times&#39;, y=self.data_label[1][band], color=self.color[band],
                        ax=plt.gca(), linewidth=0.1)

        if self.var_data_bkg.get():
            self.get_data_bkg()
            df = pd.DataFrame(self.data_bkg, index=self.times, columns=self.data_label[2])
            for band in range(len(self.energies_low)):
                df.plot(x=&#39;Times&#39;, y=self.data_label[2][band], yerr=yerr[:, band], color=self.color[band],
                        ax=plt.gca(), linewidth=1)

    plt.xticks(self.time_scale, self.plot_label)
    plt.xlabel(self.xlabel)
    plt.ylabel(self.ylabel)
    plt.title(self.title)
    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="background.BackgroundWindow" href="#background.BackgroundWindow">BackgroundWindow</a></code></h4>
<ul class="">
<li><code><a title="background.BackgroundWindow.add_bands" href="#background.BackgroundWindow.add_bands">add_bands</a></code></li>
<li><code><a title="background.BackgroundWindow.build_bkg_window" href="#background.BackgroundWindow.build_bkg_window">build_bkg_window</a></code></li>
<li><code><a title="background.BackgroundWindow.build_other_frames" href="#background.BackgroundWindow.build_other_frames">build_other_frames</a></code></li>
<li><code><a title="background.BackgroundWindow.build_second_frame" href="#background.BackgroundWindow.build_second_frame">build_second_frame</a></code></li>
<li><code><a title="background.BackgroundWindow.convert_time_to_date" href="#background.BackgroundWindow.convert_time_to_date">convert_time_to_date</a></code></li>
<li><code><a title="background.BackgroundWindow.delay_times" href="#background.BackgroundWindow.delay_times">delay_times</a></code></li>
<li><code><a title="background.BackgroundWindow.destroy" href="#background.BackgroundWindow.destroy">destroy</a></code></li>
<li><code><a title="background.BackgroundWindow.disable_bkg" href="#background.BackgroundWindow.disable_bkg">disable_bkg</a></code></li>
<li><code><a title="background.BackgroundWindow.disable_times" href="#background.BackgroundWindow.disable_times">disable_times</a></code></li>
<li><code><a title="background.BackgroundWindow.entries_list" href="#background.BackgroundWindow.entries_list">entries_list</a></code></li>
<li><code><a title="background.BackgroundWindow.find_time" href="#background.BackgroundWindow.find_time">find_time</a></code></li>
<li><code><a title="background.BackgroundWindow.fname" href="#background.BackgroundWindow.fname">fname</a></code></li>
<li><code><a title="background.BackgroundWindow.get_bkg" href="#background.BackgroundWindow.get_bkg">get_bkg</a></code></li>
<li><code><a title="background.BackgroundWindow.get_data" href="#background.BackgroundWindow.get_data">get_data</a></code></li>
<li><code><a title="background.BackgroundWindow.get_data_bkg" href="#background.BackgroundWindow.get_data_bkg">get_data_bkg</a></code></li>
<li><code><a title="background.BackgroundWindow.graphical_interval" href="#background.BackgroundWindow.graphical_interval">graphical_interval</a></code></li>
<li><code><a title="background.BackgroundWindow.load_data" href="#background.BackgroundWindow.load_data">load_data</a></code></li>
<li><code><a title="background.BackgroundWindow.open_file" href="#background.BackgroundWindow.open_file">open_file</a></code></li>
<li><code><a title="background.BackgroundWindow.open_value" href="#background.BackgroundWindow.open_value">open_value</a></code></li>
<li><code><a title="background.BackgroundWindow.plot_options" href="#background.BackgroundWindow.plot_options">plot_options</a></code></li>
<li><code><a title="background.BackgroundWindow.round_value" href="#background.BackgroundWindow.round_value">round_value</a></code></li>
<li><code><a title="background.BackgroundWindow.time_profile_plotting" href="#background.BackgroundWindow.time_profile_plotting">time_profile_plotting</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>