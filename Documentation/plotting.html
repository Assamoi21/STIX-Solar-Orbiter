<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>plotting API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>plotting</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import pandas as pd
import datetime
import re
from tkinter import *
from astropy.io import fits
from matplotlib import pyplot as plt
from matplotlib import ticker as tck
from pandas.plotting import register_matplotlib_converters

import background
from entry_int import EntryInt

register_matplotlib_converters()


class Input:
    &#34;&#34;&#34;Class to load the parameters from input data, data times, and plot Spectrum, Time Profile and Spectrogram.
       Called Units: Rate, Counts, Flux.&#34;&#34;&#34;

    def __init__(self, file, start=None, end=None, hours=None):
        &#34;&#34;&#34;When opening the .fits file, the returned object, called hdulist, behaves like a Python list and each element
        maps to a Header - Data Unit(HDU). We are primarily interested in RATE extension which contains the spectral
        data. Extracted object has two important attributes: data, which behaves like an array, can be used to access
        to the numerical data and header, which behaves like a dictionary, can be used to access to the header
        information. Also, if the start and end times are specified, extracts from the file the dates and times. \n
        Parameters: \n
            file: the file in your computer containing data you want to analyse; \n
            start: starting time of the plotting; optionnal; \n
            end: ending time of the plotting; optionnal; \n
            hours: keeps the old value for data time for future comparisons; optionnal.&#34;&#34;&#34;

        self.show = True                                # Shows the plots only if this variable is True
        if start and end and hours:                     # If &#34;Entire File&#34; checkbox is unticked:
            self.entire_file = False                        # Class will plot data for a reduced time range
        else:                                           # If &#34;Entire File&#34; checkbox is ticked:
            self.entire_file = True                         # Class will plot data for all time range

        data, data_energies, header_dates, header_energy = self.__load_data(file)  # Loading data
        self.energies_bin = header_energy[4]            # Constant used to define the plot

        self.counts = data.counts                       # Matrix contaning the counts per band in function of time time
        self.times = data.time                          # Index of times for x axis
        self.del_times = self.delay_times(data.timedel)  # List containing the difference between two successive times
        self.area = 6                                   # Value of the surface of detection (in cmÂ²) to compute the flux

        self.nb_bands = StringVar()                         # Number of energy bands to plot
        self.lower_bands = np.array(data_energies.e_low)    # Lower bounds for energy bands from .fits file
        self.upper_bands = np.array(data_energies.e_high)   # Upper bounds for energy bands from .fits file
        self.energies_low = []                              # Lower bounds for energy bands chosen by user
        self.energies_high = []                             # Upper bounds for energy bands chosen by user
        self.energies_low_index = []                        # Lower bounds indexes for energy bands chosen by user
        self.energies_high_index = []                       # Upper bounds indexes for energy bands chosen by user
        self.rounded = int()                                # Nearest value to fit in energy list; used in self.round

        if start:
            self.start_date = start                         # Starting date from import at format YYYY-MM-DD-HH-MM-SS
        else:
            self.start_date = header_dates[19]              # Starting date from header at format YYYY-MM-DD-HH-MM-SS
        if end:
            self.end_date = end                             # Ending date from import at format YYYY-MM-DD-HH-MM-SS
        else:
            self.end_date = header_dates[21]                # Ending date from header at format YYYY-MM-DD-HH-MM-SS
        if hours:
            self.hours_fixed = hours                        # Backup variable of initial time for refreshing

        self.start_time = self.find_time(self.start_date)   # Starting time in seconds
        self.end_time = self.find_time(self.end_date)       # Ending time in seconds

        self.data_start = self.find_time(header_dates[19])  # Starting time of data in seconds
        self.data_end = self.find_time(header_dates[21])    # Ending time of data in seconds

        self.index_start_list = []                  # List of all indexes included in reduced file
        self.index_end_list = []                    # List of all indexes included in reduced file
        self.index_start = int()                    # Starting time index for reduced file
        self.index_end = int()                      # Ending time index for reduced file

        self.type = str()                           # Data unit type (rate, counts, flux)
        self.data_plot = []                         # Data converted to unit type

        self.btn_info = None                        # Checkbutton &#34;Show Information&#34;
        self.info = IntVar()                        # Binary variable for checkbutton
        self.canvas_canal = StringVar()             # Canvas used to show summarized information
        self.window_elimits = None                  # Window opened to change scale of axis (linear / log) for spectrum
        self.canvas_plot = None                     # Canvas used to show energy bands entry boxes for time profile
        self.window_spec_limits = None              # Window opened to specify axis limits and scale for spectrogram

        self.btn_plot_spectrum = None               # Button to plot spectrum

        self.energy_min = None                      # Entrybox for min energy band to plot the time profile
        self.energy_max = None                      # Entrybox for max energy band to plot the time profile
        self.energy_min_list = list()               # List containing all minima of energy bands
        self.energy_max_list = list()               # List containing all maxima of energy bands
        self.text_min_energy = StringVar()          # Text &#34;Min energy&#34;
        self.text_max_energy = StringVar()          # Text &#34;Max energy&#34;

        self.ylim_min = int()                       # Min energy limit along y axis when plotting spectrogram
        self.ylim_max = int()                       # Max energy limit along y axis when plotting spectrogram
        self.e_ylim_min = StringVar()               # Entrybox containing min y limit for spectrogram
        self.e_ylim_max = StringVar()               # Entrybox containing max y limit for spectrogram
        self.text_spec_limits = StringVar()         # Text &#34;Choose your scale&#34;
        self.text_energy_elimit = StringVar()       # Text &#34;Enter min &amp; max energy for spectrogram&#34;
        self.btn_plot_spgm = None                   # Button to plot spectrogram
        self.raised_power = float()                 # Format of power for spectrogram scale legend

        self.scalex = StringVar()                   # Variable in entry box for scale of x axis
        self.scalex.set(&#34;linear&#34;)                   # Set by default to linear scale
        self.scaley = StringVar()                   # Variable in entry box for scale of y axis
        self.scaley.set(&#34;linear&#34;)                   # Set by default to linear scale
        self.rx_text = StringVar()                  # Text &#34;x axis&#34;
        self.ry_text = StringVar()                  # Text &#34;y axis&#34;
        self.rx_lin = None                          # Radiobox to choose &#39;linear&#39; for x axis
        self.rx_log = None                          # Radiobox to choose &#39;log&#39; for x axis
        self.ry_lin = None                          # Radiobox to choose &#39;linear&#39; for y axis
        self.ry_log = None                          # Radiobox to choose &#39;log&#39; for y axis

    # =================== 0. Global functions ===================

    @staticmethod
    def __load_data(file):
        &#34;&#34;&#34;Reads the Data and Header contents from input file. Loads the input file choosen in &#39;Select Input&#39; section.
        Returns respectively a table containing datas, energies, dates and channels.\n
        Parameters: \n
            file: contains the data in a fits file. \n
        Retruns: \n
            data, data_energies, header_dates, header_energy&#34;&#34;&#34;
        hdulist = fits.open(file)  # Reads the data
        hdulist.info()  # Displays the content of the read file
        return hdulist[2].data, hdulist[3].data, hdulist[0].header, hdulist[3].header

    @staticmethod
    def delay_times(data):
        &#34;&#34;&#34;Creates a TEMPORARY -1 interval, because of the step between deltimes data. Returns the shifted data. \n
        Parameters: \n
            data: original data. \n
        Returns: \n
            del_times: times delayed&#34;&#34;&#34;
        del_times = np.zeros_like(data)
        for i in range(1, len(data)):
            del_times[i] = data[i - 1]
        del_times[0] = data[0]
        return del_times

    @staticmethod
    def find_time(date):
        &#34;&#34;&#34;Converts the starting time in the data. \n
        Parameters: \n
            date: starting date as a list. \n
        Returns: \n
            found_time: time converted in seconds.&#34;&#34;&#34;
        date_split = re.split(&#39;T&#39;, date)  # Saves a tuple containing the days, and the time
        date_time = re.split(&#39;:&#39;, date_split[1])  # Splits time in 3 coponents: hr, min, s
        date_time_int = re.split(&#39;\\.&#39;, date_time[2])  # Keeps only the integer part in seconds
        found_time = int(date_time[0]) * 3600 + int(date_time[1]) * 60 + int(date_time_int[0])
        return found_time

    def acq_time(self, label):
        &#34;&#34;&#34;If not using the entire file, checks if acquisition time is &gt; 24 h and reduces data
        according to the size of chosen time period.\n
        Parameters: \n
            label: list of times indexes, in seconds.&#34;&#34;&#34;
        startIndexh = self.data_start - self.start_time
        endIndexh = self.data_end - self.start_time
        day = False  # Condition &#34;Acquisition time &gt; 24 h&#34;
        for i in label:
            if i &gt; 86400:  # If in label there is a time &gt; 86400 s
                day = True  # Acquisition time now &gt; 24 h
        if day and self.data_start &lt; 3600:  # If acquisition time &gt; 24 h
            startIndexh += 86400  # Adding 24 h
        if day and self.data_end &lt; 3600:  # If acquisition time &gt; 24 h
            endIndexh += 86400  # Adding 24 h
        self.index_start, self.index_end = self.time_index(self.times, startIndexh, endIndexh)

    def log_axis(self, window, relx, rely):
        &#34;&#34;&#34;Displays the radio boxes allowing the user to choose between linear and logarithmic axis. \n
        Parameters: \n
            window: current window on which the radio boxes need to be displayed; \n
            relx and rely: relative position of the North-West of the whole set on the window.&#34;&#34;&#34;
        self.rx_text = Label(window, text=&#34;x axis:&#34;, fg=&#39;blue&#39;)
        self.ry_text = Label(window, text=&#34;y axis:&#34;, fg=&#39;blue&#39;)
        self.rx_text.place(relx=relx, rely=rely)
        self.ry_text.place(relx=relx, rely=rely + 0.10)

        self.rx_lin = Radiobutton(window, text=&#34;Linear&#34;, variable=self.scalex, value=&#34;linear&#34;)
        self.ry_lin = Radiobutton(window, text=&#34;Linear&#34;, variable=self.scaley, value=&#34;linear&#34;)
        self.rx_log = Radiobutton(window, text=&#34;Logarithmic&#34;, variable=self.scalex, value=&#34;log&#34;)
        self.ry_log = Radiobutton(window, text=&#34;Logarithmic&#34;, variable=self.scaley, value=&#34;log&#34;)
        self.rx_lin.place(relx=relx + 0.13, rely=rely)
        self.rx_log.place(relx=relx + 0.32, rely=rely)
        self.ry_lin.place(relx=relx + 0.13, rely=rely + 0.10)
        self.ry_log.place(relx=relx + 0.32, rely=rely + 0.10)

    # =================== 1. Time Profile Plotting ===================

    def rate_vs_time_plotting(self):
        &#34;&#34;&#34;If the selected unit is rate, passes the string &#39;rate&#39; to the time profile setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;rate&#39;
        self.__time_profile_setting()

    def counts_vs_time_plotting(self):
        &#34;&#34;&#34;If the selected unit is counts, passes the string &#39;counts&#39; to the time profile setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;counts&#39;
        self.__time_profile_setting()

    def flux_vs_time_plotting(self):
        &#34;&#34;&#34;If the selected unit is flux, passes the string &#39;flux&#39; to the time profile setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;flux&#39;
        self.__time_profile_setting()

    def __time_profile_setting(self):
        &#34;&#34;&#34;Plots the function of time by selected Unit.
            Uses two frames: the first one to select values, the second one to plot figures. \n
            Parameters: \n
                typ (str): the type of plotting between &#39;rate&#39;, &#39;counts&#39;, and &#39;flux&#39;; \n
                show (bool): if True, displays the window for plot time options.&#34;&#34;&#34;
        self.from_import = False  # For now, no other file calls this function

        self.toptime = Toplevel()  # Creating new window for time profile settings
        self.toptime.title(&#39;STIX PlotTime Options&#39;)
        self.toptime.geometry(&#34;400x600&#34;)

        Label(self.toptime, text=&#34;Plot Time Profile&#34;, fg=&#34;red&#34;,
              font=&#34;Helvetica 12 bold italic&#34;).place(relx=0.5, rely=0.1, anchor=N)
        self.frame_time = LabelFrame(self.toptime, relief=RAISED, borderwidth=1)
        self.frame_time.place(relx=0.01, rely=0.05, relheight=0.9, relwidth=0.98)

        # Energy bands selection
        self.text_bands = Label(self.frame_time, text=&#34;Selection of Energy bands number: &#34;)
        self.text_bands.place(relx=0.02, rely=0.06, anchor=W)
        self.bands_choices = (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;)
        self.nb_bands = StringVar(self.frame_time)
        self.nb_bands.set(&#39;-&#39;)  # Default value
        self.selection_bands = OptionMenu(self.frame_time, self.nb_bands, *self.bands_choices)
        self.selection_bands.place(relx=0.52, rely=0.06, anchor=W)
        self.nb_bands.trace(&#34;w&#34;, self.entries_list)  # When selecting a number of bands, Entryboxes appear

        self.btn_refresh = Button(self.frame_time, text=&#39;Refresh&#39;, command=self.do_refresh)
        self.btn_refresh.place(relx=0.25, rely=0.92, anchor=N)
        self.btn_close = Button(self.frame_time, text=&#39;Close&#39;, command=self.destroy_bis)
        self.btn_close.place(relx=0.50, rely=0.92, anchor=N)

        if self.type == &#39;counts&#39;:
            self.btn_plot = Button(self.frame_time, text=&#39;Do Plot&#39;, command=self.__do_plot_counts)
        elif self.type == &#39;rate&#39;:
            self.btn_plot = Button(self.frame_time, text=&#39;Do Plot&#39;, command=self.__do_plot_rate)
        elif self.type == &#39;flux&#39;:
            self.btn_plot = Button(self.frame_time, text=&#39;Do Plot&#39;, command=self.__do_plot_flux)
        else:
            self.btn_plot = None
            print(&#34;Type not found.&#34;)

        self.btn_plot.place(relx=0.75, rely=0.92, anchor=N)

    def do_refresh(self):
        &#34;&#34;&#34;Destroys the current plotting window, resets all values for matrix plotting, and reopens the plotting window.
        Function only called as a command function in the time profile settings.&#34;&#34;&#34;
        self.toptime.destroy()
        self.__time_profile_setting()
        self.energies_low = []
        self.energies_high = []
        self.energies_low_index = []
        self.energies_high_index = []
        if not self.entire_file:
            self.start_time = self.find_time(self.hours_fixed)
        self.energy_min = None
        self.energy_max = None
        print(&#34;\nValues refreshed&#34;)

    def destroy_bis(self):
        &#34;&#34;&#34;Closes &#39;STIX PlotTime Options&#39; window when clicking &#39;Close&#39; button. Used in the time profile setting.&#34;&#34;&#34;
        self.toptime.destroy()

    def entries_list(self, frame=None, iterations=str(), log=True):
        &#34;&#34;&#34;Allows to create all buttons and Entry boxes to choose energy values.
        Creates a new window called &#39;canvas_plot&#39; if none already exists.
        Parameters:
            iterations: number of entry boxes;
            frame: where the entries are displayed; default value: None, displayed in plotting window;
            log: if True, will show radioboxes to set axes with a log scale.&#34;&#34;&#34;

        if self.from_import:  # If function is called from another file
            self.canvas_plot = frame
            self.nb_bands.set(iterations)
            entry_relx = 0.11
            entry_rely = 0.16
        else:
            self.canvas_plot = Canvas(self.toptime, width=350, height=300)
            self.canvas_plot.place(relx=0.5, rely=0.15, anchor=N)
            entry_relx = 0.2
            entry_rely = 0.05

        self.text_min_energy = Label(self.canvas_plot, text=&#34;Min energy&#34;)
        self.text_min_energy.place(relx=0.5 - entry_relx, rely=entry_rely, anchor=N)
        self.text_max_energy = Label(self.canvas_plot, text=&#34;Max energy&#34;)
        self.text_max_energy.place(relx=0.5 + entry_relx, rely=entry_rely, anchor=N)

        if log:
            # To print information about the canal sum
            self.btn_info = Checkbutton(self.canvas_plot, text=&#34;Show Information&#34;,
                                        variable=self.info, command=self.sum_canal, state=NORMAL)
            self.btn_info.place(relx=0.21, rely=0.88)

            # Scaling
            self.log_axis(self.canvas_plot, 0.12, 0.64)

        if self.nb_bands.get().isdigit():
            self.energy_min_list = [&#39;&#39;] * int(self.nb_bands.get())
            self.energy_max_list = [&#39;&#39;] * int(self.nb_bands.get())
            for i in range(int(self.nb_bands.get())):
                # Getting values for each band
                self.open_value(i)
                self.energy_min_list[i] = self.energy_min
                self.energy_max_list[i] = self.energy_max

            return self.energy_min_list, self.energy_max_list

    def sum_canal(self):
        &#34;&#34;&#34;Prints the sum of canal if the box &#34;Show information&#34; is ticked.&#34;&#34;&#34;
        if self.info.get() == 1:
            self.canvas_canal = Canvas(self.toptime, width=350, height=100, bg=&#39;ivory&#39;)
            self.canvas_canal.place(relx=0.5, rely=0.65, anchor=N)
            txt = []
            if self.energies_low_index:
                for i in range(len(self.energies_low_index)):
                    txt.append([i + 1, self.energies_low_index[i], self.energies_high_index[i]])
            else:
                print(&#39;No information currently available&#39;)

            frame_summarize_canal = LabelFrame(self.canvas_canal, relief=RAISED, borderwidth=2)
            frame_summarize_canal.place(relheight=1, relwidth=1)

            txtcanal = []
            for i in range(len(txt)):
                txtcanal.append(&#39;\nCanal selected for Energy band {} is:&#39;.format(txt[i][0]))
                txtcanal.append(txt[i][1])
                txtcanal.append(&#39;to&#39;)
                txtcanal.append(txt[i][2])

            listcanal = Text(frame_summarize_canal)
            listcanal.insert(END, str(txtcanal))
            listcanal.pack()

        else:
            print(&#39;Destroying canvas&#39;)
            self.canvas_canal.destroy()

    def open_value(self, i):
        &#34;&#34;&#34;Creates entry boxes to let the user choose the limits of the plot. \n
        Dependencies: entry_int.py&#34;&#34;&#34;
        self.energy_min = EntryInt(self.canvas_plot, width=20)
        self.energy_max = EntryInt(self.canvas_plot, width=20)

        if self.from_import:
            self.energy_min.place(relx=0.375, rely=0.27 + 0.14 * i, anchor=N)
            self.energy_max.place(relx=0.625, rely=0.27 + 0.14 * i, anchor=N)
        else:
            self.energy_min.place(relx=0.3, rely=0.14 + 0.1 * i, anchor=N)
            self.energy_max.place(relx=0.7, rely=0.14 + 0.1 * i, anchor=N)

    def __do_plot_rate(self):
        &#34;&#34;&#34;Collects rate data to do the plotting.&#34;&#34;&#34;
        self.add_bands()
        data = self.__get_data(&#34;rate&#34;)
        self.__time_profile_plotting(data, &#34;rate&#34;)

    def __do_plot_counts(self):
        &#34;&#34;&#34;Collects counts data to do the plotting.&#34;&#34;&#34;
        self.add_bands()
        data = self.__get_data(&#34;counts&#34;)
        self.__time_profile_plotting(data, &#34;counts&#34;)

    def __do_plot_flux(self):
        &#34;&#34;&#34;Collects flux data to do the plotting.&#34;&#34;&#34;
        self.add_bands()
        data = self.__get_data(&#34;flux&#34;)
        self.__time_profile_plotting(data, &#34;flux&#34;)

    def add_bands(self):
        &#34;&#34;&#34;Gets the values of plot limits from user choice.&#34;&#34;&#34;
        for i in range(int(self.nb_bands.get())):
            if self.energy_min.get() != &#39;&#39;:
                self.rounded = self.round_energy(self.lower_bands, int(self.energy_min_list[i].get()))
                a_index = (np.where(self.lower_bands == float(self.rounded)))[0][0]
                self.energies_low.append(int(self.energy_min_list[i].get()))
                self.energies_low_index.append(int(a_index))

            if self.energy_max.get() != &#39;&#39;:
                self.rounded = self.round_energy(self.upper_bands, int(self.energy_max_list[i].get()))
                b_index = (np.where(self.upper_bands == float(self.rounded)))[0][0]
                self.energies_high.append(int(self.energy_max_list[i].get()))
                self.energies_high_index.append(int(b_index))

    @staticmethod
    def round_energy(liste, value):
        &#34;&#34;&#34;Searches for the nearest number from the list. \n
        Parameters: \n
            liste: storage of researched values; \n
            value: number to round to match one of the given list.&#34;&#34;&#34;
        near = 150
        rounded = int(value)
        for i in range(len(liste)):
            diff = np.abs(value - liste[i])
            if near &gt; diff:
                near = diff
                rounded = int(liste[i])
        return rounded

    def __get_data(self, typ):
        &#34;&#34;&#34;Defines the Rate, Counts, and Flux for &#34;Plot Time Profile&#34;. \n
        Parameters: \n
            typ: type of data : rate, counts, or flux.&#34;&#34;&#34;
        data = np.zeros((len(self.times), len(self.energies_low) + 1))
        for i in range(len(self.times)):
            for j in range(len(self.energies_low) + 1):
                if j == len(self.energies_low):
                    data[i, j] = self.times[i]

                else:
                    if np.where(self.lower_bands == self.energies_low[j])[0]:
                        a = (np.where(self.lower_bands == self.energies_low[j]))[0][0]
                    else:
                        self.rounded = self.round_energy(self.lower_bands, self.energies_low[j])
                        a = (np.where(self.lower_bands == self.rounded))[0][0]
                    self.energies_low_index.append(a + 1)

                    if np.where(self.upper_bands == self.energies_high[j])[0]:
                        b = (np.where(self.upper_bands == self.energies_high[j]))[0][0]
                    else:
                        self.rounded = self.round_energy(self.upper_bands, self.energies_high[j])
                        b = (np.where(self.upper_bands == self.rounded))[0][0]
                    self.energies_high_index.append(b + 1)
                    # Determines the energy distribution for different channels relative to the time of observed data

                    # Energy channels calculation in function of plot unit
                    if typ == &#39;rate&#39;:
                        data[i, j] = sum(self.counts[i, a:(b + 1)]) / self.del_times[i]
                    elif typ == &#39;counts&#39;:
                        data[i, j] = sum(self.counts[i, a:(b + 1)])
                    elif typ == &#39;flux&#39;:
                        self.e_diff = np.abs(self.energies_high[j] - self.energies_low[j])
                        data[i, j] = sum(self.counts[i, a:(b + 1)]) / self.del_times[i] / (self.area * self.e_diff)
                    else:
                        print(&#34;Error&#34;)
                        return None

        return data  # Returns data for energy bands that can be plot

    def __time_profile_plotting(self, data, typ, show=True):
        &#34;&#34;&#34;Plots the function of time by selected Unit. Uses the colormesh function provided by matplotlib library. \n
        Parameters:
            data: data to read; \n
            typ: type of data: &#39;rate&#39;, &#39;counts&#39;, or &#39;flux&#39;; \n
            show: if True, displays the plot.&#34;&#34;&#34;
        plt.figure()
        self.columns_label = [str(low) + &#39;-&#39; + str(high) + &#39;keV&#39; for low, high in
                              zip(self.energies_low, self.energies_high)]
        self.columns_label.append(&#39;Times&#39;)
        color = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;black&#39;, &#39;orange&#39;]

        # Absciss data transformation
        self.label_time_plot = np.asarray(self.times) + self.start_time

        if self.entire_file:
            data_reduced = data
            times_reduced = self.times
        else:
            self.acq_time(self.label_time_plot)
            times_reduced = data[self.index_start:self.index_end + 1, -1]
            data_reduced = data[self.index_start:self.index_end + 1, :]

        # Plotting different figures according to chosen parameter
        if typ == &#34;rate&#34;:
            # Choosing the specific color for each energy channel
            df = pd.DataFrame(data_reduced, index=times_reduced, columns=self.columns_label)
            plt.ylabel(&#39;Rate (Counts/s) by Bands&#39;)
            plt.title(&#39;Time Profile Plotting Rate (Counts/s)&#39;)

        elif typ == &#34;counts&#34;:
            # Choosing the specific color for each energy channel
            df = pd.DataFrame(data_reduced, index=times_reduced,
                              columns=self.columns_label)
            plt.ylabel(&#39;Counts by Bands&#39;)
            plt.title(&#39;Time Profile Plotting Counts&#39;)

        elif typ == &#34;flux&#34;:
            # Choosing the specific color for each energy channel
            df = pd.DataFrame(data_reduced, index=times_reduced,
                              columns=self.columns_label)
            plt.ylabel(&#39;Flux by Bands&#39;)
            plt.title(&#39;Time Profile Plotting Flux&#39;)

        else:
            df = None
            print(&#34;Error&#34;)

        ax_bis1 = plt.gca()
        for l_bands in range(len(self.energies_low)):
            df.plot(x=&#39;Times&#39;, y=self.columns_label[l_bands], color=color[l_bands], ax=ax_bis1)

        # Absciss legend plot
        if show:
            if self.entire_file:
                file_duration = max(self.times) - min(self.times)
            else:
                file_duration = self.times[self.index_end] - self.times[self.index_start]

            if file_duration &lt;= 1800:  # file duration less than 30 minutes
                step_x = 120
            elif file_duration &lt;= 3600:  # file duration less than 1 hour
                step_x = 480
            elif file_duration &lt;= 28800:  # file duration less than 8 hours
                step_x = 3600
            else:
                step_x = 7200  # file duration more than 8 hours

            # Coloration
            if self.entire_file:
                x_positions = np.arange(0, file_duration, step_x)
            else:
                x_positions = np.arange(data[self.index_start, -1],
                                        file_duration + data[self.index_start, -1], step_x)
            x_positions_bis = x_positions + self.start_time  # pixel count at label position
            x_labels_plot = list(
                map(lambda x: (str(datetime.timedelta(seconds=x))).split(&#39;.&#39;)[0][:-3], x_positions_bis))
            x_labels_plot_days = []
            for i in range(len(x_labels_plot)):
                if &#39;day&#39; in x_labels_plot[i]:
                    x_labels_plot_days.append((x_labels_plot[i].split(&#39;,&#39;))[1])
                else:
                    x_labels_plot_days.append(x_labels_plot[i])
            plt.xticks(x_positions, x_labels_plot_days)

            # Scaling
            if self.scalex.get() == &#39;log&#39;:
                plt.xscale(&#39;log&#39;)
            if self.scaley.get() == &#39;log&#39;:
                plt.yscale(&#39;log&#39;)

            # Plotting and closing parameters window
            plt.xlabel(&#39;Start time: &#39; + str(self.start_date) + &#39; -- End time : &#39; + str(
                self.end_date))  # load start time from header and display it in X - axis
            self.toptime.destroy()
            plt.show()

    def time_index(self, index_times, value_start, value_end):
        &#34;&#34;&#34;Finds the index of start time corresponding to the chosen data. \n
        Parameters: \n
            index_times: list of indexes for time range; \n
            value_start: starting value of time range; \n
            value_end: ending value of time range.&#34;&#34;&#34;
        for i in range(len(index_times)):
            if index_times[i] &gt;= value_start:
                self.index_start_list.append(i)
            if index_times[i] &lt;= value_end:
                self.index_end_list.append(i)
        return self.index_start_list[0], self.index_end_list[-1]

    # =================== 2. Spectrum plotting ===================

    def plot_spectrum_rate(self):
        &#34;&#34;&#34;If the selected unit is rate, passes the string &#39;rate&#39; to the spectrum setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;rate&#39;
        self.__plot_spectrum()

    def plot_spectrum_counts(self):
        &#34;&#34;&#34;If the selected unit is counts, passes the string &#39;counts&#39; to the spectrum setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;counts&#39;
        self.__plot_spectrum()

    def plot_spectrum_flux(self):
        &#34;&#34;&#34;If the selected unit is flux, passes the string &#39;flux&#39; to the spectrum setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;flux&#39;
        self.__plot_spectrum()

    def __plot_spectrum(self):
        &#34;&#34;&#34;Preparing figure plotting with the data. \n
        Parameters: \n
            typ: type of data: rate, counts, or flux.&#34;&#34;&#34;
        if self.show:
            plt.figure()
        data = np.zeros(self.energies_bin)
        self.label_time_plot_spectro = np.asarray(self.times) + self.start_time

        if not self.entire_file:
            self.acq_time(self.label_time_plot_spectro)

        if self.type == &#39;rate&#39;:
            self.data_plot = self.convert_counts_rate()
            for i in range(self.energies_bin):  # for each channel
                # Determines Rate for &#34;Plot Spectrum&#34;
                if self.entire_file:
                    data[i] = np.mean(self.data_plot[:, i])
                else:
                    data[i] = np.mean(self.data_plot[self.index_start:self.index_end + 1, i])
            ylabel = &#39;counts/s&#39;
            title = &#39;STIX SOLAR Range vs Energy&#39;

        elif self.type == &#39;counts&#39;:
            for i in range(self.energies_bin):  # for each channel
                # Determines Counts for &#34;Plot Spectrum&#34;
                if self.entire_file:
                    data[i] = np.mean(self.counts[:, i])
                else:
                    data[i] = np.mean(self.counts[self.index_start:self.index_end + 1, i])
            ylabel = &#39;counts&#39;
            title = &#39;STIX SOLAR Counts vs Energy&#39;

        elif self.type == &#39;flux&#39;:
            self.data_plot = self.convert_counts_flux()
            for i in range(self.energies_bin):  # for each channel
                # Determines Flux for &#34;Plot Spectrum&#34;
                if self.entire_file:
                    data[i] = np.mean(self.data_plot[:, i]) / self.area
                else:
                    data[i] = np.mean(self.data_plot[self.index_start:self.index_end + 1, i])
            ylabel = &#39;counts/s/mmÂ²/keV&#39;
            title = &#39;STIX SOLAR Flux vs Energy&#39;

        else:
            ylabel = &#39;Unknown unit&#39;
            title = &#39;STIX SOLAR ??? vs Energy&#39;
            print(&#39;Unit not found&#39;)

        if not self.show:
            return data

        self.win_log_spec()
        plt.rcParams[&#34;figure.figsize&#34;] = [6, 6]
        plt.title(title)
        plt.plot(self.lower_bands, data, drawstyle=&#39;steps-post&#39;)  # Unit vs Energy
        plt.xlabel(&#39;Energy(keV) / Start time: &#39; + str(self.start_date) + &#39; -- End time : &#39; + str(self.end_date))
        plt.ylabel(ylabel)

    def win_log_spec(self):
        &#34;&#34;&#34;Creates a new window &#39;window_spec_limits&#39; to choose the linear or logarithmic axis for spectrum plotting.
        Calls for the log_axis function.&#34;&#34;&#34;
        self.window_spec_limits = Toplevel()
        self.window_spec_limits.title(&#39;Scales for axis&#39;)
        self.window_spec_limits.geometry(&#34;400x300&#34;)
        self.text_spec_limits = Label(self.window_spec_limits, text=&#34;Choose your scale for both x and y axis.&#34;,
                                      fg=&#39;black&#39;, font=(&#34;Times&#34;, 11))
        self.text_spec_limits.place(relx=0.5, rely=0.09, anchor=&#39;center&#39;)
        self.log_axis(self.window_spec_limits, 0.10, 0.30)
        self.btn_plot_spectrum = Button(self.window_spec_limits, text=&#34;Plot spectrum&#34;, command=self.__plot_show)
        self.btn_plot_spectrum.place(relx=0.5, rely=0.80, anchor=S, relheight=0.11, relwidth=0.25)

    def __plot_show(self):
        &#34;&#34;&#34;Closes the previous window and shows the plot for the spectrum.&#34;&#34;&#34;
        if self.scalex.get() == &#39;log&#39;:
            plt.xscale(&#39;log&#39;)
        if self.scaley.get() == &#39;log&#39;:
            plt.yscale(&#39;log&#39;)
        self.window_spec_limits.destroy()
        plt.show()

    # =================== 3. Spectrogram Plotting ===================

    def plot_spectrogram_rate(self):
        &#34;&#34;&#34;If the selected unit is rate, passes the string &#39;rate&#39; to the spectrogram setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;rate&#39;)

    def plot_spectrogram_counts(self):
        &#34;&#34;&#34;If the selected unit is counts, passes the string &#39;counts&#39; to the spectrogram setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;counts&#39;)

    def plot_spectrogram_flux(self):
        &#34;&#34;&#34;If the selected unit is flux, passes the string &#39;flux&#39; to the spectrogram setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;flux&#39;)

    def __plot_spectrogram(self, typ):
        &#34;&#34;&#34;The spectrogram is a function of Rate/Counts/Flux as a function of energy and time. x = tick(Time in h:m:s)
        and y(Energy bounds) are bounds ; z is the value *inside* those bounds (Rate/Counts/Flux). \n
        Parameters: \n
            typ: data type: rate, counts, or flux.&#34;&#34;&#34;
        # pcolormesh function(below) does not work with pandas time conversion function(TimeNew), we have to rewrite it.

        # Absciss data transformation
        self.label_time_plot_spectro = np.asarray(self.times) + self.start_time

        if self.entire_file:
            self.times_sequences = self.times
        else:
            self.acq_time(self.label_time_plot_spectro)
            self.times_sequences = self.times[self.index_start:self.index_end + 1]

        fig, self.ax = plt.subplots(1, 1, figsize=(15, 5), sharey=&#34;all&#34;, facecolor=&#39;w&#39;)
        fig.canvas.draw()

        # Limits and display
        self.specgm_lim()

        # Plotting rate
        if typ == &#39;rate&#39;:
            self.data_plot = self.convert_counts_rate()
            if self.entire_file:
                plt.pcolormesh(self.times, self.lower_bands, np.log10(np.transpose(self.data_plot)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            else:
                data_sequences = self.data_plot[self.index_start:self.index_end + 1, :]
                plt.pcolormesh(self.times_sequences, self.lower_bands, np.log10(np.transpose(data_sequences)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            plt.title(&#39;STIX SOLAR Rates Spectrogram&#39;)
            self.spgm_label = &#39;Counts/sec&#39;

        # Plotting counts
        elif typ == &#39;counts&#39;:
            if self.entire_file:
                plt.pcolormesh(self.times, self.lower_bands, np.log10(np.transpose(self.counts)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            else:
                data_sequences = self.counts[self.index_start:self.index_end + 1, :]
                plt.pcolormesh(self.times_sequences, self.lower_bands, np.log10(np.transpose(data_sequences)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            plt.title(&#39;STIX SOLAR Counts Spectrogram&#39;)
            self.spgm_label = &#39;Counts&#39;

        # Plotting flux
        elif typ == &#39;flux&#39;:
            self.data_plot = self.convert_counts_flux()
            if self.entire_file:
                plt.pcolormesh(self.times, self.lower_bands, np.log10(np.transpose(self.data_plot)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            else:
                data_sequences = self.data_plot[self.index_start:self.index_end + 1, :]
                plt.pcolormesh(self.times_sequences, self.lower_bands, np.log10(np.transpose(data_sequences)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            plt.title(&#39;STIX SOLAR Flux Spectrogram&#39;)
            self.spgm_label = &#39;counts/s/mmÂ²/keV&#39;

        else:
            print(&#39;error&#39;)

        # Defining x step
        file_duration = max(self.times_sequences) - min(self.times_sequences)
        if file_duration &lt;= 1800:  # file duration less than 30 minutes
            step_x = 120
        elif file_duration &lt;= 3600:  # file duration less than 1 hour
            step_x = 480
        elif file_duration &lt;= 28800:  # file duration less than 8 hours
            step_x = 3600
        else:  # file duration more than 8 hours
            step_x = 7200

        # x axis construction
        x_positions = np.arange(0, file_duration, step_x)

        if self.entire_file:
            x_positions_bis = x_positions + self.start_time  # pixel count at label position
            x_labels_plot = list(
                map(lambda x: (str(datetime.timedelta(seconds=x))).split(&#39;.&#39;)[0][:-3], x_positions_bis))
        else:
            x_positions_bis = np.asarray(x_positions) + self.times[self.index_start]
            x_positions_bis_label = np.asarray(x_positions) + self.label_time_plot_spectro[self.index_start]
            x_labels_plot = list(
                map(lambda x: (str(datetime.timedelta(seconds=float(x)))).split(&#39;.&#39;)[0][:-3], x_positions_bis_label))

        x_labels_plot_days = []
        for i in range(len(x_labels_plot)):
            if &#39;day&#39; in x_labels_plot[i]:
                x_labels_plot_days.append((x_labels_plot[i].split(&#39;,&#39;))[1])
            else:
                x_labels_plot_days.append(x_labels_plot[i])
        if self.entire_file:
            plt.xticks(x_positions, x_labels_plot_days)
        else:
            plt.xticks(x_positions_bis, x_labels_plot_days)

        # Ordinate legend plot
        if self.entire_file:
            self.energy_idx = self.lower_bands
            self.ene_leg = [str(a) + &#39;-&#39; + str(b) for a, b in zip(self.lower_bands, self.upper_bands)]
            self.ene_leg = np.array(self.ene_leg)

    def convert_counts_rate(self):
        &#34;&#34;&#34;Converts counts data to rate data. \n
        Rate = Counts / Time&#34;&#34;&#34;
        (self.ligne, self.colonne) = np.shape(self.counts)
        self.data_plot = np.zeros((self.ligne, self.colonne))
        for i in range(self.ligne):
            for j in range(self.colonne):
                self.data_plot[i][j] = self.counts[i][j] / self.del_times[i]
        return self.data_plot

    def convert_counts_flux(self):
        &#34;&#34;&#34;Converts counts data to flux data. \n
        Flux = Rate / (Area * Bands length) = Counts / (Time * Area * Bands length)&#34;&#34;&#34;
        (self.ligne, self.colonne) = np.shape(self.counts)
        self.data_plot = np.zeros((self.ligne, self.colonne))
        delta_e = np.zeros(shape=(len(self.lower_bands)))
        for i in range(self.ligne):
            for j in range(self.colonne):
                delta_e[j] = self.upper_bands[j] - self.lower_bands[j]  # Difference between bands
                self.data_plot[i][j] = self.counts[i][j] / self.del_times[i] / self.area / delta_e[j]
        return self.data_plot

    def specgm_lim(self):
        &#34;&#34;&#34;Displays a window to allow user to change plot scale axis for spectrogram plotting.&#34;&#34;&#34;
        # Window
        self.window_elimits = Toplevel()
        self.window_elimits.title(&#39;Energy limits&#39;)
        self.window_elimits.geometry(&#34;400x300&#34;)
        self.text_energy_elimit = Label(self.window_elimits, text=&#34;Enter the minimum and maximum energy to plot the &#34;
                                                                  &#34;spectrogram.&#34;, fg=&#39;black&#39;, font=(&#34;Times&#34;, 11))
        self.text_energy_elimit.place(relx=0.5, rely=0.09, anchor=&#39;center&#39;)

        # Limits
        self.ylim_min = 1
        self.ylim_max = 150
        self.e_ylim_min = EntryInt(self.window_elimits)
        self.e_ylim_min.place(relx=0.5, rely=0.22, relheight=0.10, relwidth=0.25, anchor=&#39;center&#39;)
        self.e_ylim_max = EntryInt(self.window_elimits)
        self.e_ylim_max.place(relx=0.5, rely=0.37, relheight=0.10, relwidth=0.25, anchor=&#39;center&#39;)

        # Scaling
        self.log_axis(self.window_elimits, 0.10, 0.50)

        # Plotting
        self.btn_plot_spgm = Button(self.window_elimits, text=&#34;Plot spectrogram&#34;, command=self.show_specgm)
        self.btn_plot_spgm.place(relx=0.5, rely=0.85, anchor=N)

    @staticmethod
    def colorbar_scale(plot, pos):
        &#34;&#34;&#34;Formats the colorbar plotted for spectrogram, displaying units as 10^x. \n
        Parameters: \n
            plot: traced spectrogram data; \n
            pos: argument necessary for the FuncFormatter from Tkinter; not of use in this function.&#34;&#34;&#34;
        decimal, power = &#39;{:.2e}&#39;.format(plot).split(&#39;e&#39;)
        raised_power = np.floor(float(decimal) * 10 ** (1 + float(power))) / 10
        return r&#39;$10^{{{}}}$&#39;.format(raised_power)

    def show_specgm(self):
        &#34;&#34;&#34;Adds all chosen values to the plot and shows the figure.&#34;&#34;&#34;
        # Limits
        if self.e_ylim_min.get().isdigit():
            self.ylim_min = int(self.e_ylim_min.get())
        else:
            self.ylim_min = 1  # Default min value
        if self.e_ylim_max.get().isdigit():
            self.ylim_max = int(self.e_ylim_max.get())
        else:
            self.ylim_max = 150  # Default max value

        # Scaling
        if self.scalex.get() == &#39;log&#39;:
            plt.xscale(&#39;log&#39;)
        if self.scaley.get() == &#39;log&#39;:
            plt.yscale(&#39;log&#39;)

        # Plotting
        self.window_elimits.destroy()
        plt.ylim(self.ylim_min, self.ylim_max)
        plt.ylabel(&#39;Energy (keV)&#39;)
        plt.xlabel(&#39;Time(UT)&#39;)
        plt.xlabel(&#39;Start time: &#39; + str(self.start_date) + &#39; -- End time : &#39; + str(self.end_date))
        plt.colorbar(ax=self.ax, label=self.spgm_label, format=tck.FuncFormatter(self.colorbar_scale))
        plt.show()


# Demo if file is run
if __name__ == &#39;__main__&#39;:

    plots = Input(background.BackgroundWindow.fname)    # any input file with .fits extension

    plots.rate_vs_time_plotting()                       # plot Count Rate vs Time
    plots.counts_vs_time_plotting()                     # plot Counts vs Time
    plots.flux_vs_time_plotting()                       # plot Count Flux vs Time
    plots.plot_spectrum_rate()                          # plot Count Rate vs Energy
    plots.plot_spectrum_counts()                        # plot Counts vs Energy
    plots.plot_spectrum_flux()                          # plot Flux vs Energy
    plots.plot_spectrogram_rate()                       # plot Count Rate Spectrogram
    plots.plot_spectrogram_counts()                     # plot Counts Spectrogram
    plots.plot_spectrogram_flux()                       # plot Flux Spectrogram</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="plotting.Input"><code class="flex name class">
<span>class <span class="ident">Input</span></span>
<span>(</span><span>file, start=None, end=None, hours=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to load the parameters from input data, data times, and plot Spectrum, Time Profile and Spectrogram.
Called Units: Rate, Counts, Flux.</p>
<p>When opening the .fits file, the returned object, called hdulist, behaves like a Python list and each element
maps to a Header - Data Unit(HDU). We are primarily interested in RATE extension which contains the spectral
data. Extracted object has two important attributes: data, which behaves like an array, can be used to access
to the numerical data and header, which behaves like a dictionary, can be used to access to the header
information. Also, if the start and end times are specified, extracts from the file the dates and times. </p>
<p>Parameters: </p>
<pre><code>file: the file in your computer containing data you want to analyse;

start: starting time of the plotting; optionnal;

end: ending time of the plotting; optionnal;

hours: keeps the old value for data time for future comparisons; optionnal.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Input:
    &#34;&#34;&#34;Class to load the parameters from input data, data times, and plot Spectrum, Time Profile and Spectrogram.
       Called Units: Rate, Counts, Flux.&#34;&#34;&#34;

    def __init__(self, file, start=None, end=None, hours=None):
        &#34;&#34;&#34;When opening the .fits file, the returned object, called hdulist, behaves like a Python list and each element
        maps to a Header - Data Unit(HDU). We are primarily interested in RATE extension which contains the spectral
        data. Extracted object has two important attributes: data, which behaves like an array, can be used to access
        to the numerical data and header, which behaves like a dictionary, can be used to access to the header
        information. Also, if the start and end times are specified, extracts from the file the dates and times. \n
        Parameters: \n
            file: the file in your computer containing data you want to analyse; \n
            start: starting time of the plotting; optionnal; \n
            end: ending time of the plotting; optionnal; \n
            hours: keeps the old value for data time for future comparisons; optionnal.&#34;&#34;&#34;

        self.show = True                                # Shows the plots only if this variable is True
        if start and end and hours:                     # If &#34;Entire File&#34; checkbox is unticked:
            self.entire_file = False                        # Class will plot data for a reduced time range
        else:                                           # If &#34;Entire File&#34; checkbox is ticked:
            self.entire_file = True                         # Class will plot data for all time range

        data, data_energies, header_dates, header_energy = self.__load_data(file)  # Loading data
        self.energies_bin = header_energy[4]            # Constant used to define the plot

        self.counts = data.counts                       # Matrix contaning the counts per band in function of time time
        self.times = data.time                          # Index of times for x axis
        self.del_times = self.delay_times(data.timedel)  # List containing the difference between two successive times
        self.area = 6                                   # Value of the surface of detection (in cmÂ²) to compute the flux

        self.nb_bands = StringVar()                         # Number of energy bands to plot
        self.lower_bands = np.array(data_energies.e_low)    # Lower bounds for energy bands from .fits file
        self.upper_bands = np.array(data_energies.e_high)   # Upper bounds for energy bands from .fits file
        self.energies_low = []                              # Lower bounds for energy bands chosen by user
        self.energies_high = []                             # Upper bounds for energy bands chosen by user
        self.energies_low_index = []                        # Lower bounds indexes for energy bands chosen by user
        self.energies_high_index = []                       # Upper bounds indexes for energy bands chosen by user
        self.rounded = int()                                # Nearest value to fit in energy list; used in self.round

        if start:
            self.start_date = start                         # Starting date from import at format YYYY-MM-DD-HH-MM-SS
        else:
            self.start_date = header_dates[19]              # Starting date from header at format YYYY-MM-DD-HH-MM-SS
        if end:
            self.end_date = end                             # Ending date from import at format YYYY-MM-DD-HH-MM-SS
        else:
            self.end_date = header_dates[21]                # Ending date from header at format YYYY-MM-DD-HH-MM-SS
        if hours:
            self.hours_fixed = hours                        # Backup variable of initial time for refreshing

        self.start_time = self.find_time(self.start_date)   # Starting time in seconds
        self.end_time = self.find_time(self.end_date)       # Ending time in seconds

        self.data_start = self.find_time(header_dates[19])  # Starting time of data in seconds
        self.data_end = self.find_time(header_dates[21])    # Ending time of data in seconds

        self.index_start_list = []                  # List of all indexes included in reduced file
        self.index_end_list = []                    # List of all indexes included in reduced file
        self.index_start = int()                    # Starting time index for reduced file
        self.index_end = int()                      # Ending time index for reduced file

        self.type = str()                           # Data unit type (rate, counts, flux)
        self.data_plot = []                         # Data converted to unit type

        self.btn_info = None                        # Checkbutton &#34;Show Information&#34;
        self.info = IntVar()                        # Binary variable for checkbutton
        self.canvas_canal = StringVar()             # Canvas used to show summarized information
        self.window_elimits = None                  # Window opened to change scale of axis (linear / log) for spectrum
        self.canvas_plot = None                     # Canvas used to show energy bands entry boxes for time profile
        self.window_spec_limits = None              # Window opened to specify axis limits and scale for spectrogram

        self.btn_plot_spectrum = None               # Button to plot spectrum

        self.energy_min = None                      # Entrybox for min energy band to plot the time profile
        self.energy_max = None                      # Entrybox for max energy band to plot the time profile
        self.energy_min_list = list()               # List containing all minima of energy bands
        self.energy_max_list = list()               # List containing all maxima of energy bands
        self.text_min_energy = StringVar()          # Text &#34;Min energy&#34;
        self.text_max_energy = StringVar()          # Text &#34;Max energy&#34;

        self.ylim_min = int()                       # Min energy limit along y axis when plotting spectrogram
        self.ylim_max = int()                       # Max energy limit along y axis when plotting spectrogram
        self.e_ylim_min = StringVar()               # Entrybox containing min y limit for spectrogram
        self.e_ylim_max = StringVar()               # Entrybox containing max y limit for spectrogram
        self.text_spec_limits = StringVar()         # Text &#34;Choose your scale&#34;
        self.text_energy_elimit = StringVar()       # Text &#34;Enter min &amp; max energy for spectrogram&#34;
        self.btn_plot_spgm = None                   # Button to plot spectrogram
        self.raised_power = float()                 # Format of power for spectrogram scale legend

        self.scalex = StringVar()                   # Variable in entry box for scale of x axis
        self.scalex.set(&#34;linear&#34;)                   # Set by default to linear scale
        self.scaley = StringVar()                   # Variable in entry box for scale of y axis
        self.scaley.set(&#34;linear&#34;)                   # Set by default to linear scale
        self.rx_text = StringVar()                  # Text &#34;x axis&#34;
        self.ry_text = StringVar()                  # Text &#34;y axis&#34;
        self.rx_lin = None                          # Radiobox to choose &#39;linear&#39; for x axis
        self.rx_log = None                          # Radiobox to choose &#39;log&#39; for x axis
        self.ry_lin = None                          # Radiobox to choose &#39;linear&#39; for y axis
        self.ry_log = None                          # Radiobox to choose &#39;log&#39; for y axis

    # =================== 0. Global functions ===================

    @staticmethod
    def __load_data(file):
        &#34;&#34;&#34;Reads the Data and Header contents from input file. Loads the input file choosen in &#39;Select Input&#39; section.
        Returns respectively a table containing datas, energies, dates and channels.\n
        Parameters: \n
            file: contains the data in a fits file. \n
        Retruns: \n
            data, data_energies, header_dates, header_energy&#34;&#34;&#34;
        hdulist = fits.open(file)  # Reads the data
        hdulist.info()  # Displays the content of the read file
        return hdulist[2].data, hdulist[3].data, hdulist[0].header, hdulist[3].header

    @staticmethod
    def delay_times(data):
        &#34;&#34;&#34;Creates a TEMPORARY -1 interval, because of the step between deltimes data. Returns the shifted data. \n
        Parameters: \n
            data: original data. \n
        Returns: \n
            del_times: times delayed&#34;&#34;&#34;
        del_times = np.zeros_like(data)
        for i in range(1, len(data)):
            del_times[i] = data[i - 1]
        del_times[0] = data[0]
        return del_times

    @staticmethod
    def find_time(date):
        &#34;&#34;&#34;Converts the starting time in the data. \n
        Parameters: \n
            date: starting date as a list. \n
        Returns: \n
            found_time: time converted in seconds.&#34;&#34;&#34;
        date_split = re.split(&#39;T&#39;, date)  # Saves a tuple containing the days, and the time
        date_time = re.split(&#39;:&#39;, date_split[1])  # Splits time in 3 coponents: hr, min, s
        date_time_int = re.split(&#39;\\.&#39;, date_time[2])  # Keeps only the integer part in seconds
        found_time = int(date_time[0]) * 3600 + int(date_time[1]) * 60 + int(date_time_int[0])
        return found_time

    def acq_time(self, label):
        &#34;&#34;&#34;If not using the entire file, checks if acquisition time is &gt; 24 h and reduces data
        according to the size of chosen time period.\n
        Parameters: \n
            label: list of times indexes, in seconds.&#34;&#34;&#34;
        startIndexh = self.data_start - self.start_time
        endIndexh = self.data_end - self.start_time
        day = False  # Condition &#34;Acquisition time &gt; 24 h&#34;
        for i in label:
            if i &gt; 86400:  # If in label there is a time &gt; 86400 s
                day = True  # Acquisition time now &gt; 24 h
        if day and self.data_start &lt; 3600:  # If acquisition time &gt; 24 h
            startIndexh += 86400  # Adding 24 h
        if day and self.data_end &lt; 3600:  # If acquisition time &gt; 24 h
            endIndexh += 86400  # Adding 24 h
        self.index_start, self.index_end = self.time_index(self.times, startIndexh, endIndexh)

    def log_axis(self, window, relx, rely):
        &#34;&#34;&#34;Displays the radio boxes allowing the user to choose between linear and logarithmic axis. \n
        Parameters: \n
            window: current window on which the radio boxes need to be displayed; \n
            relx and rely: relative position of the North-West of the whole set on the window.&#34;&#34;&#34;
        self.rx_text = Label(window, text=&#34;x axis:&#34;, fg=&#39;blue&#39;)
        self.ry_text = Label(window, text=&#34;y axis:&#34;, fg=&#39;blue&#39;)
        self.rx_text.place(relx=relx, rely=rely)
        self.ry_text.place(relx=relx, rely=rely + 0.10)

        self.rx_lin = Radiobutton(window, text=&#34;Linear&#34;, variable=self.scalex, value=&#34;linear&#34;)
        self.ry_lin = Radiobutton(window, text=&#34;Linear&#34;, variable=self.scaley, value=&#34;linear&#34;)
        self.rx_log = Radiobutton(window, text=&#34;Logarithmic&#34;, variable=self.scalex, value=&#34;log&#34;)
        self.ry_log = Radiobutton(window, text=&#34;Logarithmic&#34;, variable=self.scaley, value=&#34;log&#34;)
        self.rx_lin.place(relx=relx + 0.13, rely=rely)
        self.rx_log.place(relx=relx + 0.32, rely=rely)
        self.ry_lin.place(relx=relx + 0.13, rely=rely + 0.10)
        self.ry_log.place(relx=relx + 0.32, rely=rely + 0.10)

    # =================== 1. Time Profile Plotting ===================

    def rate_vs_time_plotting(self):
        &#34;&#34;&#34;If the selected unit is rate, passes the string &#39;rate&#39; to the time profile setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;rate&#39;
        self.__time_profile_setting()

    def counts_vs_time_plotting(self):
        &#34;&#34;&#34;If the selected unit is counts, passes the string &#39;counts&#39; to the time profile setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;counts&#39;
        self.__time_profile_setting()

    def flux_vs_time_plotting(self):
        &#34;&#34;&#34;If the selected unit is flux, passes the string &#39;flux&#39; to the time profile setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;flux&#39;
        self.__time_profile_setting()

    def __time_profile_setting(self):
        &#34;&#34;&#34;Plots the function of time by selected Unit.
            Uses two frames: the first one to select values, the second one to plot figures. \n
            Parameters: \n
                typ (str): the type of plotting between &#39;rate&#39;, &#39;counts&#39;, and &#39;flux&#39;; \n
                show (bool): if True, displays the window for plot time options.&#34;&#34;&#34;
        self.from_import = False  # For now, no other file calls this function

        self.toptime = Toplevel()  # Creating new window for time profile settings
        self.toptime.title(&#39;STIX PlotTime Options&#39;)
        self.toptime.geometry(&#34;400x600&#34;)

        Label(self.toptime, text=&#34;Plot Time Profile&#34;, fg=&#34;red&#34;,
              font=&#34;Helvetica 12 bold italic&#34;).place(relx=0.5, rely=0.1, anchor=N)
        self.frame_time = LabelFrame(self.toptime, relief=RAISED, borderwidth=1)
        self.frame_time.place(relx=0.01, rely=0.05, relheight=0.9, relwidth=0.98)

        # Energy bands selection
        self.text_bands = Label(self.frame_time, text=&#34;Selection of Energy bands number: &#34;)
        self.text_bands.place(relx=0.02, rely=0.06, anchor=W)
        self.bands_choices = (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;)
        self.nb_bands = StringVar(self.frame_time)
        self.nb_bands.set(&#39;-&#39;)  # Default value
        self.selection_bands = OptionMenu(self.frame_time, self.nb_bands, *self.bands_choices)
        self.selection_bands.place(relx=0.52, rely=0.06, anchor=W)
        self.nb_bands.trace(&#34;w&#34;, self.entries_list)  # When selecting a number of bands, Entryboxes appear

        self.btn_refresh = Button(self.frame_time, text=&#39;Refresh&#39;, command=self.do_refresh)
        self.btn_refresh.place(relx=0.25, rely=0.92, anchor=N)
        self.btn_close = Button(self.frame_time, text=&#39;Close&#39;, command=self.destroy_bis)
        self.btn_close.place(relx=0.50, rely=0.92, anchor=N)

        if self.type == &#39;counts&#39;:
            self.btn_plot = Button(self.frame_time, text=&#39;Do Plot&#39;, command=self.__do_plot_counts)
        elif self.type == &#39;rate&#39;:
            self.btn_plot = Button(self.frame_time, text=&#39;Do Plot&#39;, command=self.__do_plot_rate)
        elif self.type == &#39;flux&#39;:
            self.btn_plot = Button(self.frame_time, text=&#39;Do Plot&#39;, command=self.__do_plot_flux)
        else:
            self.btn_plot = None
            print(&#34;Type not found.&#34;)

        self.btn_plot.place(relx=0.75, rely=0.92, anchor=N)

    def do_refresh(self):
        &#34;&#34;&#34;Destroys the current plotting window, resets all values for matrix plotting, and reopens the plotting window.
        Function only called as a command function in the time profile settings.&#34;&#34;&#34;
        self.toptime.destroy()
        self.__time_profile_setting()
        self.energies_low = []
        self.energies_high = []
        self.energies_low_index = []
        self.energies_high_index = []
        if not self.entire_file:
            self.start_time = self.find_time(self.hours_fixed)
        self.energy_min = None
        self.energy_max = None
        print(&#34;\nValues refreshed&#34;)

    def destroy_bis(self):
        &#34;&#34;&#34;Closes &#39;STIX PlotTime Options&#39; window when clicking &#39;Close&#39; button. Used in the time profile setting.&#34;&#34;&#34;
        self.toptime.destroy()

    def entries_list(self, frame=None, iterations=str(), log=True):
        &#34;&#34;&#34;Allows to create all buttons and Entry boxes to choose energy values.
        Creates a new window called &#39;canvas_plot&#39; if none already exists.
        Parameters:
            iterations: number of entry boxes;
            frame: where the entries are displayed; default value: None, displayed in plotting window;
            log: if True, will show radioboxes to set axes with a log scale.&#34;&#34;&#34;

        if self.from_import:  # If function is called from another file
            self.canvas_plot = frame
            self.nb_bands.set(iterations)
            entry_relx = 0.11
            entry_rely = 0.16
        else:
            self.canvas_plot = Canvas(self.toptime, width=350, height=300)
            self.canvas_plot.place(relx=0.5, rely=0.15, anchor=N)
            entry_relx = 0.2
            entry_rely = 0.05

        self.text_min_energy = Label(self.canvas_plot, text=&#34;Min energy&#34;)
        self.text_min_energy.place(relx=0.5 - entry_relx, rely=entry_rely, anchor=N)
        self.text_max_energy = Label(self.canvas_plot, text=&#34;Max energy&#34;)
        self.text_max_energy.place(relx=0.5 + entry_relx, rely=entry_rely, anchor=N)

        if log:
            # To print information about the canal sum
            self.btn_info = Checkbutton(self.canvas_plot, text=&#34;Show Information&#34;,
                                        variable=self.info, command=self.sum_canal, state=NORMAL)
            self.btn_info.place(relx=0.21, rely=0.88)

            # Scaling
            self.log_axis(self.canvas_plot, 0.12, 0.64)

        if self.nb_bands.get().isdigit():
            self.energy_min_list = [&#39;&#39;] * int(self.nb_bands.get())
            self.energy_max_list = [&#39;&#39;] * int(self.nb_bands.get())
            for i in range(int(self.nb_bands.get())):
                # Getting values for each band
                self.open_value(i)
                self.energy_min_list[i] = self.energy_min
                self.energy_max_list[i] = self.energy_max

            return self.energy_min_list, self.energy_max_list

    def sum_canal(self):
        &#34;&#34;&#34;Prints the sum of canal if the box &#34;Show information&#34; is ticked.&#34;&#34;&#34;
        if self.info.get() == 1:
            self.canvas_canal = Canvas(self.toptime, width=350, height=100, bg=&#39;ivory&#39;)
            self.canvas_canal.place(relx=0.5, rely=0.65, anchor=N)
            txt = []
            if self.energies_low_index:
                for i in range(len(self.energies_low_index)):
                    txt.append([i + 1, self.energies_low_index[i], self.energies_high_index[i]])
            else:
                print(&#39;No information currently available&#39;)

            frame_summarize_canal = LabelFrame(self.canvas_canal, relief=RAISED, borderwidth=2)
            frame_summarize_canal.place(relheight=1, relwidth=1)

            txtcanal = []
            for i in range(len(txt)):
                txtcanal.append(&#39;\nCanal selected for Energy band {} is:&#39;.format(txt[i][0]))
                txtcanal.append(txt[i][1])
                txtcanal.append(&#39;to&#39;)
                txtcanal.append(txt[i][2])

            listcanal = Text(frame_summarize_canal)
            listcanal.insert(END, str(txtcanal))
            listcanal.pack()

        else:
            print(&#39;Destroying canvas&#39;)
            self.canvas_canal.destroy()

    def open_value(self, i):
        &#34;&#34;&#34;Creates entry boxes to let the user choose the limits of the plot. \n
        Dependencies: entry_int.py&#34;&#34;&#34;
        self.energy_min = EntryInt(self.canvas_plot, width=20)
        self.energy_max = EntryInt(self.canvas_plot, width=20)

        if self.from_import:
            self.energy_min.place(relx=0.375, rely=0.27 + 0.14 * i, anchor=N)
            self.energy_max.place(relx=0.625, rely=0.27 + 0.14 * i, anchor=N)
        else:
            self.energy_min.place(relx=0.3, rely=0.14 + 0.1 * i, anchor=N)
            self.energy_max.place(relx=0.7, rely=0.14 + 0.1 * i, anchor=N)

    def __do_plot_rate(self):
        &#34;&#34;&#34;Collects rate data to do the plotting.&#34;&#34;&#34;
        self.add_bands()
        data = self.__get_data(&#34;rate&#34;)
        self.__time_profile_plotting(data, &#34;rate&#34;)

    def __do_plot_counts(self):
        &#34;&#34;&#34;Collects counts data to do the plotting.&#34;&#34;&#34;
        self.add_bands()
        data = self.__get_data(&#34;counts&#34;)
        self.__time_profile_plotting(data, &#34;counts&#34;)

    def __do_plot_flux(self):
        &#34;&#34;&#34;Collects flux data to do the plotting.&#34;&#34;&#34;
        self.add_bands()
        data = self.__get_data(&#34;flux&#34;)
        self.__time_profile_plotting(data, &#34;flux&#34;)

    def add_bands(self):
        &#34;&#34;&#34;Gets the values of plot limits from user choice.&#34;&#34;&#34;
        for i in range(int(self.nb_bands.get())):
            if self.energy_min.get() != &#39;&#39;:
                self.rounded = self.round_energy(self.lower_bands, int(self.energy_min_list[i].get()))
                a_index = (np.where(self.lower_bands == float(self.rounded)))[0][0]
                self.energies_low.append(int(self.energy_min_list[i].get()))
                self.energies_low_index.append(int(a_index))

            if self.energy_max.get() != &#39;&#39;:
                self.rounded = self.round_energy(self.upper_bands, int(self.energy_max_list[i].get()))
                b_index = (np.where(self.upper_bands == float(self.rounded)))[0][0]
                self.energies_high.append(int(self.energy_max_list[i].get()))
                self.energies_high_index.append(int(b_index))

    @staticmethod
    def round_energy(liste, value):
        &#34;&#34;&#34;Searches for the nearest number from the list. \n
        Parameters: \n
            liste: storage of researched values; \n
            value: number to round to match one of the given list.&#34;&#34;&#34;
        near = 150
        rounded = int(value)
        for i in range(len(liste)):
            diff = np.abs(value - liste[i])
            if near &gt; diff:
                near = diff
                rounded = int(liste[i])
        return rounded

    def __get_data(self, typ):
        &#34;&#34;&#34;Defines the Rate, Counts, and Flux for &#34;Plot Time Profile&#34;. \n
        Parameters: \n
            typ: type of data : rate, counts, or flux.&#34;&#34;&#34;
        data = np.zeros((len(self.times), len(self.energies_low) + 1))
        for i in range(len(self.times)):
            for j in range(len(self.energies_low) + 1):
                if j == len(self.energies_low):
                    data[i, j] = self.times[i]

                else:
                    if np.where(self.lower_bands == self.energies_low[j])[0]:
                        a = (np.where(self.lower_bands == self.energies_low[j]))[0][0]
                    else:
                        self.rounded = self.round_energy(self.lower_bands, self.energies_low[j])
                        a = (np.where(self.lower_bands == self.rounded))[0][0]
                    self.energies_low_index.append(a + 1)

                    if np.where(self.upper_bands == self.energies_high[j])[0]:
                        b = (np.where(self.upper_bands == self.energies_high[j]))[0][0]
                    else:
                        self.rounded = self.round_energy(self.upper_bands, self.energies_high[j])
                        b = (np.where(self.upper_bands == self.rounded))[0][0]
                    self.energies_high_index.append(b + 1)
                    # Determines the energy distribution for different channels relative to the time of observed data

                    # Energy channels calculation in function of plot unit
                    if typ == &#39;rate&#39;:
                        data[i, j] = sum(self.counts[i, a:(b + 1)]) / self.del_times[i]
                    elif typ == &#39;counts&#39;:
                        data[i, j] = sum(self.counts[i, a:(b + 1)])
                    elif typ == &#39;flux&#39;:
                        self.e_diff = np.abs(self.energies_high[j] - self.energies_low[j])
                        data[i, j] = sum(self.counts[i, a:(b + 1)]) / self.del_times[i] / (self.area * self.e_diff)
                    else:
                        print(&#34;Error&#34;)
                        return None

        return data  # Returns data for energy bands that can be plot

    def __time_profile_plotting(self, data, typ, show=True):
        &#34;&#34;&#34;Plots the function of time by selected Unit. Uses the colormesh function provided by matplotlib library. \n
        Parameters:
            data: data to read; \n
            typ: type of data: &#39;rate&#39;, &#39;counts&#39;, or &#39;flux&#39;; \n
            show: if True, displays the plot.&#34;&#34;&#34;
        plt.figure()
        self.columns_label = [str(low) + &#39;-&#39; + str(high) + &#39;keV&#39; for low, high in
                              zip(self.energies_low, self.energies_high)]
        self.columns_label.append(&#39;Times&#39;)
        color = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;, &#39;black&#39;, &#39;orange&#39;]

        # Absciss data transformation
        self.label_time_plot = np.asarray(self.times) + self.start_time

        if self.entire_file:
            data_reduced = data
            times_reduced = self.times
        else:
            self.acq_time(self.label_time_plot)
            times_reduced = data[self.index_start:self.index_end + 1, -1]
            data_reduced = data[self.index_start:self.index_end + 1, :]

        # Plotting different figures according to chosen parameter
        if typ == &#34;rate&#34;:
            # Choosing the specific color for each energy channel
            df = pd.DataFrame(data_reduced, index=times_reduced, columns=self.columns_label)
            plt.ylabel(&#39;Rate (Counts/s) by Bands&#39;)
            plt.title(&#39;Time Profile Plotting Rate (Counts/s)&#39;)

        elif typ == &#34;counts&#34;:
            # Choosing the specific color for each energy channel
            df = pd.DataFrame(data_reduced, index=times_reduced,
                              columns=self.columns_label)
            plt.ylabel(&#39;Counts by Bands&#39;)
            plt.title(&#39;Time Profile Plotting Counts&#39;)

        elif typ == &#34;flux&#34;:
            # Choosing the specific color for each energy channel
            df = pd.DataFrame(data_reduced, index=times_reduced,
                              columns=self.columns_label)
            plt.ylabel(&#39;Flux by Bands&#39;)
            plt.title(&#39;Time Profile Plotting Flux&#39;)

        else:
            df = None
            print(&#34;Error&#34;)

        ax_bis1 = plt.gca()
        for l_bands in range(len(self.energies_low)):
            df.plot(x=&#39;Times&#39;, y=self.columns_label[l_bands], color=color[l_bands], ax=ax_bis1)

        # Absciss legend plot
        if show:
            if self.entire_file:
                file_duration = max(self.times) - min(self.times)
            else:
                file_duration = self.times[self.index_end] - self.times[self.index_start]

            if file_duration &lt;= 1800:  # file duration less than 30 minutes
                step_x = 120
            elif file_duration &lt;= 3600:  # file duration less than 1 hour
                step_x = 480
            elif file_duration &lt;= 28800:  # file duration less than 8 hours
                step_x = 3600
            else:
                step_x = 7200  # file duration more than 8 hours

            # Coloration
            if self.entire_file:
                x_positions = np.arange(0, file_duration, step_x)
            else:
                x_positions = np.arange(data[self.index_start, -1],
                                        file_duration + data[self.index_start, -1], step_x)
            x_positions_bis = x_positions + self.start_time  # pixel count at label position
            x_labels_plot = list(
                map(lambda x: (str(datetime.timedelta(seconds=x))).split(&#39;.&#39;)[0][:-3], x_positions_bis))
            x_labels_plot_days = []
            for i in range(len(x_labels_plot)):
                if &#39;day&#39; in x_labels_plot[i]:
                    x_labels_plot_days.append((x_labels_plot[i].split(&#39;,&#39;))[1])
                else:
                    x_labels_plot_days.append(x_labels_plot[i])
            plt.xticks(x_positions, x_labels_plot_days)

            # Scaling
            if self.scalex.get() == &#39;log&#39;:
                plt.xscale(&#39;log&#39;)
            if self.scaley.get() == &#39;log&#39;:
                plt.yscale(&#39;log&#39;)

            # Plotting and closing parameters window
            plt.xlabel(&#39;Start time: &#39; + str(self.start_date) + &#39; -- End time : &#39; + str(
                self.end_date))  # load start time from header and display it in X - axis
            self.toptime.destroy()
            plt.show()

    def time_index(self, index_times, value_start, value_end):
        &#34;&#34;&#34;Finds the index of start time corresponding to the chosen data. \n
        Parameters: \n
            index_times: list of indexes for time range; \n
            value_start: starting value of time range; \n
            value_end: ending value of time range.&#34;&#34;&#34;
        for i in range(len(index_times)):
            if index_times[i] &gt;= value_start:
                self.index_start_list.append(i)
            if index_times[i] &lt;= value_end:
                self.index_end_list.append(i)
        return self.index_start_list[0], self.index_end_list[-1]

    # =================== 2. Spectrum plotting ===================

    def plot_spectrum_rate(self):
        &#34;&#34;&#34;If the selected unit is rate, passes the string &#39;rate&#39; to the spectrum setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;rate&#39;
        self.__plot_spectrum()

    def plot_spectrum_counts(self):
        &#34;&#34;&#34;If the selected unit is counts, passes the string &#39;counts&#39; to the spectrum setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;counts&#39;
        self.__plot_spectrum()

    def plot_spectrum_flux(self):
        &#34;&#34;&#34;If the selected unit is flux, passes the string &#39;flux&#39; to the spectrum setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.type = &#39;flux&#39;
        self.__plot_spectrum()

    def __plot_spectrum(self):
        &#34;&#34;&#34;Preparing figure plotting with the data. \n
        Parameters: \n
            typ: type of data: rate, counts, or flux.&#34;&#34;&#34;
        if self.show:
            plt.figure()
        data = np.zeros(self.energies_bin)
        self.label_time_plot_spectro = np.asarray(self.times) + self.start_time

        if not self.entire_file:
            self.acq_time(self.label_time_plot_spectro)

        if self.type == &#39;rate&#39;:
            self.data_plot = self.convert_counts_rate()
            for i in range(self.energies_bin):  # for each channel
                # Determines Rate for &#34;Plot Spectrum&#34;
                if self.entire_file:
                    data[i] = np.mean(self.data_plot[:, i])
                else:
                    data[i] = np.mean(self.data_plot[self.index_start:self.index_end + 1, i])
            ylabel = &#39;counts/s&#39;
            title = &#39;STIX SOLAR Range vs Energy&#39;

        elif self.type == &#39;counts&#39;:
            for i in range(self.energies_bin):  # for each channel
                # Determines Counts for &#34;Plot Spectrum&#34;
                if self.entire_file:
                    data[i] = np.mean(self.counts[:, i])
                else:
                    data[i] = np.mean(self.counts[self.index_start:self.index_end + 1, i])
            ylabel = &#39;counts&#39;
            title = &#39;STIX SOLAR Counts vs Energy&#39;

        elif self.type == &#39;flux&#39;:
            self.data_plot = self.convert_counts_flux()
            for i in range(self.energies_bin):  # for each channel
                # Determines Flux for &#34;Plot Spectrum&#34;
                if self.entire_file:
                    data[i] = np.mean(self.data_plot[:, i]) / self.area
                else:
                    data[i] = np.mean(self.data_plot[self.index_start:self.index_end + 1, i])
            ylabel = &#39;counts/s/mmÂ²/keV&#39;
            title = &#39;STIX SOLAR Flux vs Energy&#39;

        else:
            ylabel = &#39;Unknown unit&#39;
            title = &#39;STIX SOLAR ??? vs Energy&#39;
            print(&#39;Unit not found&#39;)

        if not self.show:
            return data

        self.win_log_spec()
        plt.rcParams[&#34;figure.figsize&#34;] = [6, 6]
        plt.title(title)
        plt.plot(self.lower_bands, data, drawstyle=&#39;steps-post&#39;)  # Unit vs Energy
        plt.xlabel(&#39;Energy(keV) / Start time: &#39; + str(self.start_date) + &#39; -- End time : &#39; + str(self.end_date))
        plt.ylabel(ylabel)

    def win_log_spec(self):
        &#34;&#34;&#34;Creates a new window &#39;window_spec_limits&#39; to choose the linear or logarithmic axis for spectrum plotting.
        Calls for the log_axis function.&#34;&#34;&#34;
        self.window_spec_limits = Toplevel()
        self.window_spec_limits.title(&#39;Scales for axis&#39;)
        self.window_spec_limits.geometry(&#34;400x300&#34;)
        self.text_spec_limits = Label(self.window_spec_limits, text=&#34;Choose your scale for both x and y axis.&#34;,
                                      fg=&#39;black&#39;, font=(&#34;Times&#34;, 11))
        self.text_spec_limits.place(relx=0.5, rely=0.09, anchor=&#39;center&#39;)
        self.log_axis(self.window_spec_limits, 0.10, 0.30)
        self.btn_plot_spectrum = Button(self.window_spec_limits, text=&#34;Plot spectrum&#34;, command=self.__plot_show)
        self.btn_plot_spectrum.place(relx=0.5, rely=0.80, anchor=S, relheight=0.11, relwidth=0.25)

    def __plot_show(self):
        &#34;&#34;&#34;Closes the previous window and shows the plot for the spectrum.&#34;&#34;&#34;
        if self.scalex.get() == &#39;log&#39;:
            plt.xscale(&#39;log&#39;)
        if self.scaley.get() == &#39;log&#39;:
            plt.yscale(&#39;log&#39;)
        self.window_spec_limits.destroy()
        plt.show()

    # =================== 3. Spectrogram Plotting ===================

    def plot_spectrogram_rate(self):
        &#34;&#34;&#34;If the selected unit is rate, passes the string &#39;rate&#39; to the spectrogram setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;rate&#39;)

    def plot_spectrogram_counts(self):
        &#34;&#34;&#34;If the selected unit is counts, passes the string &#39;counts&#39; to the spectrogram setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;counts&#39;)

    def plot_spectrogram_flux(self):
        &#34;&#34;&#34;If the selected unit is flux, passes the string &#39;flux&#39; to the spectrogram setting. \n
        Dependencies: second.py&#34;&#34;&#34;
        self.__plot_spectrogram(&#39;flux&#39;)

    def __plot_spectrogram(self, typ):
        &#34;&#34;&#34;The spectrogram is a function of Rate/Counts/Flux as a function of energy and time. x = tick(Time in h:m:s)
        and y(Energy bounds) are bounds ; z is the value *inside* those bounds (Rate/Counts/Flux). \n
        Parameters: \n
            typ: data type: rate, counts, or flux.&#34;&#34;&#34;
        # pcolormesh function(below) does not work with pandas time conversion function(TimeNew), we have to rewrite it.

        # Absciss data transformation
        self.label_time_plot_spectro = np.asarray(self.times) + self.start_time

        if self.entire_file:
            self.times_sequences = self.times
        else:
            self.acq_time(self.label_time_plot_spectro)
            self.times_sequences = self.times[self.index_start:self.index_end + 1]

        fig, self.ax = plt.subplots(1, 1, figsize=(15, 5), sharey=&#34;all&#34;, facecolor=&#39;w&#39;)
        fig.canvas.draw()

        # Limits and display
        self.specgm_lim()

        # Plotting rate
        if typ == &#39;rate&#39;:
            self.data_plot = self.convert_counts_rate()
            if self.entire_file:
                plt.pcolormesh(self.times, self.lower_bands, np.log10(np.transpose(self.data_plot)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            else:
                data_sequences = self.data_plot[self.index_start:self.index_end + 1, :]
                plt.pcolormesh(self.times_sequences, self.lower_bands, np.log10(np.transpose(data_sequences)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            plt.title(&#39;STIX SOLAR Rates Spectrogram&#39;)
            self.spgm_label = &#39;Counts/sec&#39;

        # Plotting counts
        elif typ == &#39;counts&#39;:
            if self.entire_file:
                plt.pcolormesh(self.times, self.lower_bands, np.log10(np.transpose(self.counts)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            else:
                data_sequences = self.counts[self.index_start:self.index_end + 1, :]
                plt.pcolormesh(self.times_sequences, self.lower_bands, np.log10(np.transpose(data_sequences)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            plt.title(&#39;STIX SOLAR Counts Spectrogram&#39;)
            self.spgm_label = &#39;Counts&#39;

        # Plotting flux
        elif typ == &#39;flux&#39;:
            self.data_plot = self.convert_counts_flux()
            if self.entire_file:
                plt.pcolormesh(self.times, self.lower_bands, np.log10(np.transpose(self.data_plot)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            else:
                data_sequences = self.data_plot[self.index_start:self.index_end + 1, :]
                plt.pcolormesh(self.times_sequences, self.lower_bands, np.log10(np.transpose(data_sequences)),
                               shading=&#39;auto&#39;, cmap=&#39;coolwarm&#39;)
            plt.title(&#39;STIX SOLAR Flux Spectrogram&#39;)
            self.spgm_label = &#39;counts/s/mmÂ²/keV&#39;

        else:
            print(&#39;error&#39;)

        # Defining x step
        file_duration = max(self.times_sequences) - min(self.times_sequences)
        if file_duration &lt;= 1800:  # file duration less than 30 minutes
            step_x = 120
        elif file_duration &lt;= 3600:  # file duration less than 1 hour
            step_x = 480
        elif file_duration &lt;= 28800:  # file duration less than 8 hours
            step_x = 3600
        else:  # file duration more than 8 hours
            step_x = 7200

        # x axis construction
        x_positions = np.arange(0, file_duration, step_x)

        if self.entire_file:
            x_positions_bis = x_positions + self.start_time  # pixel count at label position
            x_labels_plot = list(
                map(lambda x: (str(datetime.timedelta(seconds=x))).split(&#39;.&#39;)[0][:-3], x_positions_bis))
        else:
            x_positions_bis = np.asarray(x_positions) + self.times[self.index_start]
            x_positions_bis_label = np.asarray(x_positions) + self.label_time_plot_spectro[self.index_start]
            x_labels_plot = list(
                map(lambda x: (str(datetime.timedelta(seconds=float(x)))).split(&#39;.&#39;)[0][:-3], x_positions_bis_label))

        x_labels_plot_days = []
        for i in range(len(x_labels_plot)):
            if &#39;day&#39; in x_labels_plot[i]:
                x_labels_plot_days.append((x_labels_plot[i].split(&#39;,&#39;))[1])
            else:
                x_labels_plot_days.append(x_labels_plot[i])
        if self.entire_file:
            plt.xticks(x_positions, x_labels_plot_days)
        else:
            plt.xticks(x_positions_bis, x_labels_plot_days)

        # Ordinate legend plot
        if self.entire_file:
            self.energy_idx = self.lower_bands
            self.ene_leg = [str(a) + &#39;-&#39; + str(b) for a, b in zip(self.lower_bands, self.upper_bands)]
            self.ene_leg = np.array(self.ene_leg)

    def convert_counts_rate(self):
        &#34;&#34;&#34;Converts counts data to rate data. \n
        Rate = Counts / Time&#34;&#34;&#34;
        (self.ligne, self.colonne) = np.shape(self.counts)
        self.data_plot = np.zeros((self.ligne, self.colonne))
        for i in range(self.ligne):
            for j in range(self.colonne):
                self.data_plot[i][j] = self.counts[i][j] / self.del_times[i]
        return self.data_plot

    def convert_counts_flux(self):
        &#34;&#34;&#34;Converts counts data to flux data. \n
        Flux = Rate / (Area * Bands length) = Counts / (Time * Area * Bands length)&#34;&#34;&#34;
        (self.ligne, self.colonne) = np.shape(self.counts)
        self.data_plot = np.zeros((self.ligne, self.colonne))
        delta_e = np.zeros(shape=(len(self.lower_bands)))
        for i in range(self.ligne):
            for j in range(self.colonne):
                delta_e[j] = self.upper_bands[j] - self.lower_bands[j]  # Difference between bands
                self.data_plot[i][j] = self.counts[i][j] / self.del_times[i] / self.area / delta_e[j]
        return self.data_plot

    def specgm_lim(self):
        &#34;&#34;&#34;Displays a window to allow user to change plot scale axis for spectrogram plotting.&#34;&#34;&#34;
        # Window
        self.window_elimits = Toplevel()
        self.window_elimits.title(&#39;Energy limits&#39;)
        self.window_elimits.geometry(&#34;400x300&#34;)
        self.text_energy_elimit = Label(self.window_elimits, text=&#34;Enter the minimum and maximum energy to plot the &#34;
                                                                  &#34;spectrogram.&#34;, fg=&#39;black&#39;, font=(&#34;Times&#34;, 11))
        self.text_energy_elimit.place(relx=0.5, rely=0.09, anchor=&#39;center&#39;)

        # Limits
        self.ylim_min = 1
        self.ylim_max = 150
        self.e_ylim_min = EntryInt(self.window_elimits)
        self.e_ylim_min.place(relx=0.5, rely=0.22, relheight=0.10, relwidth=0.25, anchor=&#39;center&#39;)
        self.e_ylim_max = EntryInt(self.window_elimits)
        self.e_ylim_max.place(relx=0.5, rely=0.37, relheight=0.10, relwidth=0.25, anchor=&#39;center&#39;)

        # Scaling
        self.log_axis(self.window_elimits, 0.10, 0.50)

        # Plotting
        self.btn_plot_spgm = Button(self.window_elimits, text=&#34;Plot spectrogram&#34;, command=self.show_specgm)
        self.btn_plot_spgm.place(relx=0.5, rely=0.85, anchor=N)

    @staticmethod
    def colorbar_scale(plot, pos):
        &#34;&#34;&#34;Formats the colorbar plotted for spectrogram, displaying units as 10^x. \n
        Parameters: \n
            plot: traced spectrogram data; \n
            pos: argument necessary for the FuncFormatter from Tkinter; not of use in this function.&#34;&#34;&#34;
        decimal, power = &#39;{:.2e}&#39;.format(plot).split(&#39;e&#39;)
        raised_power = np.floor(float(decimal) * 10 ** (1 + float(power))) / 10
        return r&#39;$10^{{{}}}$&#39;.format(raised_power)

    def show_specgm(self):
        &#34;&#34;&#34;Adds all chosen values to the plot and shows the figure.&#34;&#34;&#34;
        # Limits
        if self.e_ylim_min.get().isdigit():
            self.ylim_min = int(self.e_ylim_min.get())
        else:
            self.ylim_min = 1  # Default min value
        if self.e_ylim_max.get().isdigit():
            self.ylim_max = int(self.e_ylim_max.get())
        else:
            self.ylim_max = 150  # Default max value

        # Scaling
        if self.scalex.get() == &#39;log&#39;:
            plt.xscale(&#39;log&#39;)
        if self.scaley.get() == &#39;log&#39;:
            plt.yscale(&#39;log&#39;)

        # Plotting
        self.window_elimits.destroy()
        plt.ylim(self.ylim_min, self.ylim_max)
        plt.ylabel(&#39;Energy (keV)&#39;)
        plt.xlabel(&#39;Time(UT)&#39;)
        plt.xlabel(&#39;Start time: &#39; + str(self.start_date) + &#39; -- End time : &#39; + str(self.end_date))
        plt.colorbar(ax=self.ax, label=self.spgm_label, format=tck.FuncFormatter(self.colorbar_scale))
        plt.show()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="plotting.Input.colorbar_scale"><code class="name flex">
<span>def <span class="ident">colorbar_scale</span></span>(<span>plot, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Formats the colorbar plotted for spectrogram, displaying units as 10^x. </p>
<p>Parameters: </p>
<pre><code>plot: traced spectrogram data;

pos: argument necessary for the FuncFormatter from Tkinter; not of use in this function.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def colorbar_scale(plot, pos):
    &#34;&#34;&#34;Formats the colorbar plotted for spectrogram, displaying units as 10^x. \n
    Parameters: \n
        plot: traced spectrogram data; \n
        pos: argument necessary for the FuncFormatter from Tkinter; not of use in this function.&#34;&#34;&#34;
    decimal, power = &#39;{:.2e}&#39;.format(plot).split(&#39;e&#39;)
    raised_power = np.floor(float(decimal) * 10 ** (1 + float(power))) / 10
    return r&#39;$10^{{{}}}$&#39;.format(raised_power)</code></pre>
</details>
</dd>
<dt id="plotting.Input.delay_times"><code class="name flex">
<span>def <span class="ident">delay_times</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a TEMPORARY -1 interval, because of the step between deltimes data. Returns the shifted data. </p>
<p>Parameters: </p>
<pre><code>data: original data.
</code></pre>
<p>Returns: </p>
<pre><code>del_times: times delayed
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def delay_times(data):
    &#34;&#34;&#34;Creates a TEMPORARY -1 interval, because of the step between deltimes data. Returns the shifted data. \n
    Parameters: \n
        data: original data. \n
    Returns: \n
        del_times: times delayed&#34;&#34;&#34;
    del_times = np.zeros_like(data)
    for i in range(1, len(data)):
        del_times[i] = data[i - 1]
    del_times[0] = data[0]
    return del_times</code></pre>
</details>
</dd>
<dt id="plotting.Input.find_time"><code class="name flex">
<span>def <span class="ident">find_time</span></span>(<span>date)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the starting time in the data. </p>
<p>Parameters: </p>
<pre><code>date: starting date as a list.
</code></pre>
<p>Returns: </p>
<pre><code>found_time: time converted in seconds.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def find_time(date):
    &#34;&#34;&#34;Converts the starting time in the data. \n
    Parameters: \n
        date: starting date as a list. \n
    Returns: \n
        found_time: time converted in seconds.&#34;&#34;&#34;
    date_split = re.split(&#39;T&#39;, date)  # Saves a tuple containing the days, and the time
    date_time = re.split(&#39;:&#39;, date_split[1])  # Splits time in 3 coponents: hr, min, s
    date_time_int = re.split(&#39;\\.&#39;, date_time[2])  # Keeps only the integer part in seconds
    found_time = int(date_time[0]) * 3600 + int(date_time[1]) * 60 + int(date_time_int[0])
    return found_time</code></pre>
</details>
</dd>
<dt id="plotting.Input.round_energy"><code class="name flex">
<span>def <span class="ident">round_energy</span></span>(<span>liste, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for the nearest number from the list. </p>
<p>Parameters: </p>
<pre><code>liste: storage of researched values;

value: number to round to match one of the given list.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def round_energy(liste, value):
    &#34;&#34;&#34;Searches for the nearest number from the list. \n
    Parameters: \n
        liste: storage of researched values; \n
        value: number to round to match one of the given list.&#34;&#34;&#34;
    near = 150
    rounded = int(value)
    for i in range(len(liste)):
        diff = np.abs(value - liste[i])
        if near &gt; diff:
            near = diff
            rounded = int(liste[i])
    return rounded</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="plotting.Input.acq_time"><code class="name flex">
<span>def <span class="ident">acq_time</span></span>(<span>self, label)</span>
</code></dt>
<dd>
<div class="desc"><p>If not using the entire file, checks if acquisition time is &gt; 24 h and reduces data
according to the size of chosen time period.</p>
<p>Parameters: </p>
<pre><code>label: list of times indexes, in seconds.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acq_time(self, label):
    &#34;&#34;&#34;If not using the entire file, checks if acquisition time is &gt; 24 h and reduces data
    according to the size of chosen time period.\n
    Parameters: \n
        label: list of times indexes, in seconds.&#34;&#34;&#34;
    startIndexh = self.data_start - self.start_time
    endIndexh = self.data_end - self.start_time
    day = False  # Condition &#34;Acquisition time &gt; 24 h&#34;
    for i in label:
        if i &gt; 86400:  # If in label there is a time &gt; 86400 s
            day = True  # Acquisition time now &gt; 24 h
    if day and self.data_start &lt; 3600:  # If acquisition time &gt; 24 h
        startIndexh += 86400  # Adding 24 h
    if day and self.data_end &lt; 3600:  # If acquisition time &gt; 24 h
        endIndexh += 86400  # Adding 24 h
    self.index_start, self.index_end = self.time_index(self.times, startIndexh, endIndexh)</code></pre>
</details>
</dd>
<dt id="plotting.Input.add_bands"><code class="name flex">
<span>def <span class="ident">add_bands</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the values of plot limits from user choice.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_bands(self):
    &#34;&#34;&#34;Gets the values of plot limits from user choice.&#34;&#34;&#34;
    for i in range(int(self.nb_bands.get())):
        if self.energy_min.get() != &#39;&#39;:
            self.rounded = self.round_energy(self.lower_bands, int(self.energy_min_list[i].get()))
            a_index = (np.where(self.lower_bands == float(self.rounded)))[0][0]
            self.energies_low.append(int(self.energy_min_list[i].get()))
            self.energies_low_index.append(int(a_index))

        if self.energy_max.get() != &#39;&#39;:
            self.rounded = self.round_energy(self.upper_bands, int(self.energy_max_list[i].get()))
            b_index = (np.where(self.upper_bands == float(self.rounded)))[0][0]
            self.energies_high.append(int(self.energy_max_list[i].get()))
            self.energies_high_index.append(int(b_index))</code></pre>
</details>
</dd>
<dt id="plotting.Input.convert_counts_flux"><code class="name flex">
<span>def <span class="ident">convert_counts_flux</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts counts data to flux data. </p>
<p>Flux = Rate / (Area * Bands length) = Counts / (Time * Area * Bands length)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_counts_flux(self):
    &#34;&#34;&#34;Converts counts data to flux data. \n
    Flux = Rate / (Area * Bands length) = Counts / (Time * Area * Bands length)&#34;&#34;&#34;
    (self.ligne, self.colonne) = np.shape(self.counts)
    self.data_plot = np.zeros((self.ligne, self.colonne))
    delta_e = np.zeros(shape=(len(self.lower_bands)))
    for i in range(self.ligne):
        for j in range(self.colonne):
            delta_e[j] = self.upper_bands[j] - self.lower_bands[j]  # Difference between bands
            self.data_plot[i][j] = self.counts[i][j] / self.del_times[i] / self.area / delta_e[j]
    return self.data_plot</code></pre>
</details>
</dd>
<dt id="plotting.Input.convert_counts_rate"><code class="name flex">
<span>def <span class="ident">convert_counts_rate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts counts data to rate data. </p>
<p>Rate = Counts / Time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_counts_rate(self):
    &#34;&#34;&#34;Converts counts data to rate data. \n
    Rate = Counts / Time&#34;&#34;&#34;
    (self.ligne, self.colonne) = np.shape(self.counts)
    self.data_plot = np.zeros((self.ligne, self.colonne))
    for i in range(self.ligne):
        for j in range(self.colonne):
            self.data_plot[i][j] = self.counts[i][j] / self.del_times[i]
    return self.data_plot</code></pre>
</details>
</dd>
<dt id="plotting.Input.counts_vs_time_plotting"><code class="name flex">
<span>def <span class="ident">counts_vs_time_plotting</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the selected unit is counts, passes the string 'counts' to the time profile setting. </p>
<p>Dependencies: second.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counts_vs_time_plotting(self):
    &#34;&#34;&#34;If the selected unit is counts, passes the string &#39;counts&#39; to the time profile setting. \n
    Dependencies: second.py&#34;&#34;&#34;
    self.type = &#39;counts&#39;
    self.__time_profile_setting()</code></pre>
</details>
</dd>
<dt id="plotting.Input.destroy_bis"><code class="name flex">
<span>def <span class="ident">destroy_bis</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes 'STIX PlotTime Options' window when clicking 'Close' button. Used in the time profile setting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy_bis(self):
    &#34;&#34;&#34;Closes &#39;STIX PlotTime Options&#39; window when clicking &#39;Close&#39; button. Used in the time profile setting.&#34;&#34;&#34;
    self.toptime.destroy()</code></pre>
</details>
</dd>
<dt id="plotting.Input.do_refresh"><code class="name flex">
<span>def <span class="ident">do_refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Destroys the current plotting window, resets all values for matrix plotting, and reopens the plotting window.
Function only called as a command function in the time profile settings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_refresh(self):
    &#34;&#34;&#34;Destroys the current plotting window, resets all values for matrix plotting, and reopens the plotting window.
    Function only called as a command function in the time profile settings.&#34;&#34;&#34;
    self.toptime.destroy()
    self.__time_profile_setting()
    self.energies_low = []
    self.energies_high = []
    self.energies_low_index = []
    self.energies_high_index = []
    if not self.entire_file:
        self.start_time = self.find_time(self.hours_fixed)
    self.energy_min = None
    self.energy_max = None
    print(&#34;\nValues refreshed&#34;)</code></pre>
</details>
</dd>
<dt id="plotting.Input.entries_list"><code class="name flex">
<span>def <span class="ident">entries_list</span></span>(<span>self, frame=None, iterations='', log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows to create all buttons and Entry boxes to choose energy values.
Creates a new window called 'canvas_plot' if none already exists.</p>
<h2 id="parameters">Parameters</h2>
<p>iterations: number of entry boxes;
frame: where the entries are displayed; default value: None, displayed in plotting window;
log: if True, will show radioboxes to set axes with a log scale.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def entries_list(self, frame=None, iterations=str(), log=True):
    &#34;&#34;&#34;Allows to create all buttons and Entry boxes to choose energy values.
    Creates a new window called &#39;canvas_plot&#39; if none already exists.
    Parameters:
        iterations: number of entry boxes;
        frame: where the entries are displayed; default value: None, displayed in plotting window;
        log: if True, will show radioboxes to set axes with a log scale.&#34;&#34;&#34;

    if self.from_import:  # If function is called from another file
        self.canvas_plot = frame
        self.nb_bands.set(iterations)
        entry_relx = 0.11
        entry_rely = 0.16
    else:
        self.canvas_plot = Canvas(self.toptime, width=350, height=300)
        self.canvas_plot.place(relx=0.5, rely=0.15, anchor=N)
        entry_relx = 0.2
        entry_rely = 0.05

    self.text_min_energy = Label(self.canvas_plot, text=&#34;Min energy&#34;)
    self.text_min_energy.place(relx=0.5 - entry_relx, rely=entry_rely, anchor=N)
    self.text_max_energy = Label(self.canvas_plot, text=&#34;Max energy&#34;)
    self.text_max_energy.place(relx=0.5 + entry_relx, rely=entry_rely, anchor=N)

    if log:
        # To print information about the canal sum
        self.btn_info = Checkbutton(self.canvas_plot, text=&#34;Show Information&#34;,
                                    variable=self.info, command=self.sum_canal, state=NORMAL)
        self.btn_info.place(relx=0.21, rely=0.88)

        # Scaling
        self.log_axis(self.canvas_plot, 0.12, 0.64)

    if self.nb_bands.get().isdigit():
        self.energy_min_list = [&#39;&#39;] * int(self.nb_bands.get())
        self.energy_max_list = [&#39;&#39;] * int(self.nb_bands.get())
        for i in range(int(self.nb_bands.get())):
            # Getting values for each band
            self.open_value(i)
            self.energy_min_list[i] = self.energy_min
            self.energy_max_list[i] = self.energy_max

        return self.energy_min_list, self.energy_max_list</code></pre>
</details>
</dd>
<dt id="plotting.Input.flux_vs_time_plotting"><code class="name flex">
<span>def <span class="ident">flux_vs_time_plotting</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the selected unit is flux, passes the string 'flux' to the time profile setting. </p>
<p>Dependencies: second.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flux_vs_time_plotting(self):
    &#34;&#34;&#34;If the selected unit is flux, passes the string &#39;flux&#39; to the time profile setting. \n
    Dependencies: second.py&#34;&#34;&#34;
    self.type = &#39;flux&#39;
    self.__time_profile_setting()</code></pre>
</details>
</dd>
<dt id="plotting.Input.log_axis"><code class="name flex">
<span>def <span class="ident">log_axis</span></span>(<span>self, window, relx, rely)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays the radio boxes allowing the user to choose between linear and logarithmic axis. </p>
<p>Parameters: </p>
<pre><code>window: current window on which the radio boxes need to be displayed;

relx and rely: relative position of the North-West of the whole set on the window.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_axis(self, window, relx, rely):
    &#34;&#34;&#34;Displays the radio boxes allowing the user to choose between linear and logarithmic axis. \n
    Parameters: \n
        window: current window on which the radio boxes need to be displayed; \n
        relx and rely: relative position of the North-West of the whole set on the window.&#34;&#34;&#34;
    self.rx_text = Label(window, text=&#34;x axis:&#34;, fg=&#39;blue&#39;)
    self.ry_text = Label(window, text=&#34;y axis:&#34;, fg=&#39;blue&#39;)
    self.rx_text.place(relx=relx, rely=rely)
    self.ry_text.place(relx=relx, rely=rely + 0.10)

    self.rx_lin = Radiobutton(window, text=&#34;Linear&#34;, variable=self.scalex, value=&#34;linear&#34;)
    self.ry_lin = Radiobutton(window, text=&#34;Linear&#34;, variable=self.scaley, value=&#34;linear&#34;)
    self.rx_log = Radiobutton(window, text=&#34;Logarithmic&#34;, variable=self.scalex, value=&#34;log&#34;)
    self.ry_log = Radiobutton(window, text=&#34;Logarithmic&#34;, variable=self.scaley, value=&#34;log&#34;)
    self.rx_lin.place(relx=relx + 0.13, rely=rely)
    self.rx_log.place(relx=relx + 0.32, rely=rely)
    self.ry_lin.place(relx=relx + 0.13, rely=rely + 0.10)
    self.ry_log.place(relx=relx + 0.32, rely=rely + 0.10)</code></pre>
</details>
</dd>
<dt id="plotting.Input.open_value"><code class="name flex">
<span>def <span class="ident">open_value</span></span>(<span>self, i)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates entry boxes to let the user choose the limits of the plot. </p>
<p>Dependencies: entry_int.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_value(self, i):
    &#34;&#34;&#34;Creates entry boxes to let the user choose the limits of the plot. \n
    Dependencies: entry_int.py&#34;&#34;&#34;
    self.energy_min = EntryInt(self.canvas_plot, width=20)
    self.energy_max = EntryInt(self.canvas_plot, width=20)

    if self.from_import:
        self.energy_min.place(relx=0.375, rely=0.27 + 0.14 * i, anchor=N)
        self.energy_max.place(relx=0.625, rely=0.27 + 0.14 * i, anchor=N)
    else:
        self.energy_min.place(relx=0.3, rely=0.14 + 0.1 * i, anchor=N)
        self.energy_max.place(relx=0.7, rely=0.14 + 0.1 * i, anchor=N)</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrogram_counts"><code class="name flex">
<span>def <span class="ident">plot_spectrogram_counts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the selected unit is counts, passes the string 'counts' to the spectrogram setting. </p>
<p>Dependencies: second.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrogram_counts(self):
    &#34;&#34;&#34;If the selected unit is counts, passes the string &#39;counts&#39; to the spectrogram setting. \n
    Dependencies: second.py&#34;&#34;&#34;
    self.__plot_spectrogram(&#39;counts&#39;)</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrogram_flux"><code class="name flex">
<span>def <span class="ident">plot_spectrogram_flux</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the selected unit is flux, passes the string 'flux' to the spectrogram setting. </p>
<p>Dependencies: second.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrogram_flux(self):
    &#34;&#34;&#34;If the selected unit is flux, passes the string &#39;flux&#39; to the spectrogram setting. \n
    Dependencies: second.py&#34;&#34;&#34;
    self.__plot_spectrogram(&#39;flux&#39;)</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrogram_rate"><code class="name flex">
<span>def <span class="ident">plot_spectrogram_rate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the selected unit is rate, passes the string 'rate' to the spectrogram setting. </p>
<p>Dependencies: second.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrogram_rate(self):
    &#34;&#34;&#34;If the selected unit is rate, passes the string &#39;rate&#39; to the spectrogram setting. \n
    Dependencies: second.py&#34;&#34;&#34;
    self.__plot_spectrogram(&#39;rate&#39;)</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrum_counts"><code class="name flex">
<span>def <span class="ident">plot_spectrum_counts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the selected unit is counts, passes the string 'counts' to the spectrum setting. </p>
<p>Dependencies: second.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrum_counts(self):
    &#34;&#34;&#34;If the selected unit is counts, passes the string &#39;counts&#39; to the spectrum setting. \n
    Dependencies: second.py&#34;&#34;&#34;
    self.type = &#39;counts&#39;
    self.__plot_spectrum()</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrum_flux"><code class="name flex">
<span>def <span class="ident">plot_spectrum_flux</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the selected unit is flux, passes the string 'flux' to the spectrum setting. </p>
<p>Dependencies: second.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrum_flux(self):
    &#34;&#34;&#34;If the selected unit is flux, passes the string &#39;flux&#39; to the spectrum setting. \n
    Dependencies: second.py&#34;&#34;&#34;
    self.type = &#39;flux&#39;
    self.__plot_spectrum()</code></pre>
</details>
</dd>
<dt id="plotting.Input.plot_spectrum_rate"><code class="name flex">
<span>def <span class="ident">plot_spectrum_rate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the selected unit is rate, passes the string 'rate' to the spectrum setting. </p>
<p>Dependencies: second.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_spectrum_rate(self):
    &#34;&#34;&#34;If the selected unit is rate, passes the string &#39;rate&#39; to the spectrum setting. \n
    Dependencies: second.py&#34;&#34;&#34;
    self.type = &#39;rate&#39;
    self.__plot_spectrum()</code></pre>
</details>
</dd>
<dt id="plotting.Input.rate_vs_time_plotting"><code class="name flex">
<span>def <span class="ident">rate_vs_time_plotting</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If the selected unit is rate, passes the string 'rate' to the time profile setting. </p>
<p>Dependencies: second.py</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rate_vs_time_plotting(self):
    &#34;&#34;&#34;If the selected unit is rate, passes the string &#39;rate&#39; to the time profile setting. \n
    Dependencies: second.py&#34;&#34;&#34;
    self.type = &#39;rate&#39;
    self.__time_profile_setting()</code></pre>
</details>
</dd>
<dt id="plotting.Input.show_specgm"><code class="name flex">
<span>def <span class="ident">show_specgm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds all chosen values to the plot and shows the figure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_specgm(self):
    &#34;&#34;&#34;Adds all chosen values to the plot and shows the figure.&#34;&#34;&#34;
    # Limits
    if self.e_ylim_min.get().isdigit():
        self.ylim_min = int(self.e_ylim_min.get())
    else:
        self.ylim_min = 1  # Default min value
    if self.e_ylim_max.get().isdigit():
        self.ylim_max = int(self.e_ylim_max.get())
    else:
        self.ylim_max = 150  # Default max value

    # Scaling
    if self.scalex.get() == &#39;log&#39;:
        plt.xscale(&#39;log&#39;)
    if self.scaley.get() == &#39;log&#39;:
        plt.yscale(&#39;log&#39;)

    # Plotting
    self.window_elimits.destroy()
    plt.ylim(self.ylim_min, self.ylim_max)
    plt.ylabel(&#39;Energy (keV)&#39;)
    plt.xlabel(&#39;Time(UT)&#39;)
    plt.xlabel(&#39;Start time: &#39; + str(self.start_date) + &#39; -- End time : &#39; + str(self.end_date))
    plt.colorbar(ax=self.ax, label=self.spgm_label, format=tck.FuncFormatter(self.colorbar_scale))
    plt.show()</code></pre>
</details>
</dd>
<dt id="plotting.Input.specgm_lim"><code class="name flex">
<span>def <span class="ident">specgm_lim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays a window to allow user to change plot scale axis for spectrogram plotting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def specgm_lim(self):
    &#34;&#34;&#34;Displays a window to allow user to change plot scale axis for spectrogram plotting.&#34;&#34;&#34;
    # Window
    self.window_elimits = Toplevel()
    self.window_elimits.title(&#39;Energy limits&#39;)
    self.window_elimits.geometry(&#34;400x300&#34;)
    self.text_energy_elimit = Label(self.window_elimits, text=&#34;Enter the minimum and maximum energy to plot the &#34;
                                                              &#34;spectrogram.&#34;, fg=&#39;black&#39;, font=(&#34;Times&#34;, 11))
    self.text_energy_elimit.place(relx=0.5, rely=0.09, anchor=&#39;center&#39;)

    # Limits
    self.ylim_min = 1
    self.ylim_max = 150
    self.e_ylim_min = EntryInt(self.window_elimits)
    self.e_ylim_min.place(relx=0.5, rely=0.22, relheight=0.10, relwidth=0.25, anchor=&#39;center&#39;)
    self.e_ylim_max = EntryInt(self.window_elimits)
    self.e_ylim_max.place(relx=0.5, rely=0.37, relheight=0.10, relwidth=0.25, anchor=&#39;center&#39;)

    # Scaling
    self.log_axis(self.window_elimits, 0.10, 0.50)

    # Plotting
    self.btn_plot_spgm = Button(self.window_elimits, text=&#34;Plot spectrogram&#34;, command=self.show_specgm)
    self.btn_plot_spgm.place(relx=0.5, rely=0.85, anchor=N)</code></pre>
</details>
</dd>
<dt id="plotting.Input.sum_canal"><code class="name flex">
<span>def <span class="ident">sum_canal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the sum of canal if the box "Show information" is ticked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum_canal(self):
    &#34;&#34;&#34;Prints the sum of canal if the box &#34;Show information&#34; is ticked.&#34;&#34;&#34;
    if self.info.get() == 1:
        self.canvas_canal = Canvas(self.toptime, width=350, height=100, bg=&#39;ivory&#39;)
        self.canvas_canal.place(relx=0.5, rely=0.65, anchor=N)
        txt = []
        if self.energies_low_index:
            for i in range(len(self.energies_low_index)):
                txt.append([i + 1, self.energies_low_index[i], self.energies_high_index[i]])
        else:
            print(&#39;No information currently available&#39;)

        frame_summarize_canal = LabelFrame(self.canvas_canal, relief=RAISED, borderwidth=2)
        frame_summarize_canal.place(relheight=1, relwidth=1)

        txtcanal = []
        for i in range(len(txt)):
            txtcanal.append(&#39;\nCanal selected for Energy band {} is:&#39;.format(txt[i][0]))
            txtcanal.append(txt[i][1])
            txtcanal.append(&#39;to&#39;)
            txtcanal.append(txt[i][2])

        listcanal = Text(frame_summarize_canal)
        listcanal.insert(END, str(txtcanal))
        listcanal.pack()

    else:
        print(&#39;Destroying canvas&#39;)
        self.canvas_canal.destroy()</code></pre>
</details>
</dd>
<dt id="plotting.Input.time_index"><code class="name flex">
<span>def <span class="ident">time_index</span></span>(<span>self, index_times, value_start, value_end)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the index of start time corresponding to the chosen data. </p>
<p>Parameters: </p>
<pre><code>index_times: list of indexes for time range;

value_start: starting value of time range;

value_end: ending value of time range.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_index(self, index_times, value_start, value_end):
    &#34;&#34;&#34;Finds the index of start time corresponding to the chosen data. \n
    Parameters: \n
        index_times: list of indexes for time range; \n
        value_start: starting value of time range; \n
        value_end: ending value of time range.&#34;&#34;&#34;
    for i in range(len(index_times)):
        if index_times[i] &gt;= value_start:
            self.index_start_list.append(i)
        if index_times[i] &lt;= value_end:
            self.index_end_list.append(i)
    return self.index_start_list[0], self.index_end_list[-1]</code></pre>
</details>
</dd>
<dt id="plotting.Input.win_log_spec"><code class="name flex">
<span>def <span class="ident">win_log_spec</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new window 'window_spec_limits' to choose the linear or logarithmic axis for spectrum plotting.
Calls for the log_axis function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def win_log_spec(self):
    &#34;&#34;&#34;Creates a new window &#39;window_spec_limits&#39; to choose the linear or logarithmic axis for spectrum plotting.
    Calls for the log_axis function.&#34;&#34;&#34;
    self.window_spec_limits = Toplevel()
    self.window_spec_limits.title(&#39;Scales for axis&#39;)
    self.window_spec_limits.geometry(&#34;400x300&#34;)
    self.text_spec_limits = Label(self.window_spec_limits, text=&#34;Choose your scale for both x and y axis.&#34;,
                                  fg=&#39;black&#39;, font=(&#34;Times&#34;, 11))
    self.text_spec_limits.place(relx=0.5, rely=0.09, anchor=&#39;center&#39;)
    self.log_axis(self.window_spec_limits, 0.10, 0.30)
    self.btn_plot_spectrum = Button(self.window_spec_limits, text=&#34;Plot spectrum&#34;, command=self.__plot_show)
    self.btn_plot_spectrum.place(relx=0.5, rely=0.80, anchor=S, relheight=0.11, relwidth=0.25)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="plotting.Input" href="#plotting.Input">Input</a></code></h4>
<ul class="">
<li><code><a title="plotting.Input.acq_time" href="#plotting.Input.acq_time">acq_time</a></code></li>
<li><code><a title="plotting.Input.add_bands" href="#plotting.Input.add_bands">add_bands</a></code></li>
<li><code><a title="plotting.Input.colorbar_scale" href="#plotting.Input.colorbar_scale">colorbar_scale</a></code></li>
<li><code><a title="plotting.Input.convert_counts_flux" href="#plotting.Input.convert_counts_flux">convert_counts_flux</a></code></li>
<li><code><a title="plotting.Input.convert_counts_rate" href="#plotting.Input.convert_counts_rate">convert_counts_rate</a></code></li>
<li><code><a title="plotting.Input.counts_vs_time_plotting" href="#plotting.Input.counts_vs_time_plotting">counts_vs_time_plotting</a></code></li>
<li><code><a title="plotting.Input.delay_times" href="#plotting.Input.delay_times">delay_times</a></code></li>
<li><code><a title="plotting.Input.destroy_bis" href="#plotting.Input.destroy_bis">destroy_bis</a></code></li>
<li><code><a title="plotting.Input.do_refresh" href="#plotting.Input.do_refresh">do_refresh</a></code></li>
<li><code><a title="plotting.Input.entries_list" href="#plotting.Input.entries_list">entries_list</a></code></li>
<li><code><a title="plotting.Input.find_time" href="#plotting.Input.find_time">find_time</a></code></li>
<li><code><a title="plotting.Input.flux_vs_time_plotting" href="#plotting.Input.flux_vs_time_plotting">flux_vs_time_plotting</a></code></li>
<li><code><a title="plotting.Input.log_axis" href="#plotting.Input.log_axis">log_axis</a></code></li>
<li><code><a title="plotting.Input.open_value" href="#plotting.Input.open_value">open_value</a></code></li>
<li><code><a title="plotting.Input.plot_spectrogram_counts" href="#plotting.Input.plot_spectrogram_counts">plot_spectrogram_counts</a></code></li>
<li><code><a title="plotting.Input.plot_spectrogram_flux" href="#plotting.Input.plot_spectrogram_flux">plot_spectrogram_flux</a></code></li>
<li><code><a title="plotting.Input.plot_spectrogram_rate" href="#plotting.Input.plot_spectrogram_rate">plot_spectrogram_rate</a></code></li>
<li><code><a title="plotting.Input.plot_spectrum_counts" href="#plotting.Input.plot_spectrum_counts">plot_spectrum_counts</a></code></li>
<li><code><a title="plotting.Input.plot_spectrum_flux" href="#plotting.Input.plot_spectrum_flux">plot_spectrum_flux</a></code></li>
<li><code><a title="plotting.Input.plot_spectrum_rate" href="#plotting.Input.plot_spectrum_rate">plot_spectrum_rate</a></code></li>
<li><code><a title="plotting.Input.rate_vs_time_plotting" href="#plotting.Input.rate_vs_time_plotting">rate_vs_time_plotting</a></code></li>
<li><code><a title="plotting.Input.round_energy" href="#plotting.Input.round_energy">round_energy</a></code></li>
<li><code><a title="plotting.Input.show_specgm" href="#plotting.Input.show_specgm">show_specgm</a></code></li>
<li><code><a title="plotting.Input.specgm_lim" href="#plotting.Input.specgm_lim">specgm_lim</a></code></li>
<li><code><a title="plotting.Input.sum_canal" href="#plotting.Input.sum_canal">sum_canal</a></code></li>
<li><code><a title="plotting.Input.time_index" href="#plotting.Input.time_index">time_index</a></code></li>
<li><code><a title="plotting.Input.win_log_spec" href="#plotting.Input.win_log_spec">win_log_spec</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>